{
    version: 3,
    sources: [
    "../node_modules/ssr-window/ssr-window.esm.js",
    "../node_modules/dom7/dom7.esm.js",
    "../src/shared/dom.js",
    "../src/shared/utils.js",
    "../src/shared/get-support.js",
    "../src/shared/get-device.js",
    "../src/shared/get-browser.js",
    "../src/core/events-emitter.js",
    "../src/core/update/index.js",
    "../src/core/update/updateSize.js",
    "../src/core/update/updateSlides.js",
    "../src/core/update/updateAutoHeight.js",
    "../src/core/update/updateSlidesOffset.js",
    "../src/core/update/updateSlidesProgress.js",
    "../src/core/update/updateProgress.js",
    "../src/core/update/updateSlidesClasses.js",
    "../src/core/update/updateActiveIndex.js",
    "../src/core/update/updateClickedSlide.js",
    "../src/core/translate/index.js",
    "../src/core/translate/getTranslate.js",
    "../src/core/translate/setTranslate.js",
    "../src/core/translate/minTranslate.js",
    "../src/core/translate/maxTranslate.js",
    "../src/core/translate/translateTo.js",
    "../src/core/transition/transitionEmit.js",
    "../src/core/slide/index.js",
    "../src/core/slide/slideTo.js",
    "../src/core/slide/slideToLoop.js",
    "../src/core/slide/slideNext.js",
    "../src/core/slide/slidePrev.js",
    "../src/core/slide/slideReset.js",
    "../src/core/slide/slideToClosest.js",
    "../src/core/slide/slideToClickedSlide.js",
    "../src/core/loop/index.js",
    "../src/core/loop/loopCreate.js",
    "../src/core/loop/loopFix.js",
    "../src/core/loop/loopDestroy.js",
    "../src/core/events/onTouchStart.js",
    "../src/core/events/onTouchMove.js",
    "../src/core/events/onTouchEnd.js",
    "../src/core/events/onResize.js",
    "../src/core/events/onClick.js",
    "../src/core/events/onScroll.js",
    "../src/core/events/index.js",
    "../src/core/breakpoints/setBreakpoint.js",
    "../src/core/classes/index.js",
    "../src/core/classes/addClasses.js",
    "../src/core/classes/removeClasses.js",
    "../src/core/check-overflow/index.js",
    "../src/core/defaults.js",
    "../src/core/moduleExtendParams.js",
    "../src/core/core.js",
    "../src/core/transition/index.js",
    "../src/core/transition/setTransition.js",
    "../src/core/transition/transitionStart.js",
    "../src/core/transition/transitionEnd.js",
    "../src/core/grab-cursor/index.js",
    "../src/core/grab-cursor/setGrabCursor.js",
    "../src/core/grab-cursor/unsetGrabCursor.js",
    "../src/core/breakpoints/index.js",
    "../src/core/breakpoints/getBreakpoint.js",
    "../src/core/images/index.js",
    "../src/core/images/loadImage.js",
    "../src/core/images/preloadImages.js",
    "../src/shared/create-element-if-not-defined.js",
    "../src/shared/classes-to-selector.js",
    "../src/modules/manipulation/methods/appendSlide.js",
    "../src/modules/manipulation/methods/prependSlide.js",
    "../src/modules/manipulation/methods/addSlide.js",
    "../src/modules/manipulation/methods/removeSlide.js",
    "../src/modules/manipulation/methods/removeAllSlides.js",
    "../src/shared/effect-init.js",
    "../src/shared/effect-target.js",
    "../src/shared/effect-virtual-transition-end.js",
    "../src/shared/create-shadow.js",
    "../src/core/modules/resize/resize.js",
    "../src/core/modules/observer/observer.js",
    "../src/swiper.js",
    "../src/modules/virtual/virtual.js",
    "../src/modules/keyboard/keyboard.js",
    "../src/modules/mousewheel/mousewheel.js",
    "../src/modules/navigation/navigation.js",
    "../src/modules/pagination/pagination.js",
    "../src/modules/scrollbar/scrollbar.js",
    "../src/modules/parallax/parallax.js",
    "../src/modules/zoom/zoom.js",
    "../src/modules/lazy/lazy.js",
    "../src/modules/controller/controller.js",
    "../src/modules/a11y/a11y.js",
    "../src/modules/history/history.js",
    "../src/modules/hash-navigation/hash-navigation.js",
    "../src/modules/autoplay/autoplay.js",
    "../src/modules/thumbs/thumbs.js",
    "../src/modules/free-mode/free-mode.js",
    "../src/modules/grid/grid.js",
    "../src/modules/manipulation/manipulation.js",
    "../src/modules/effect-fade/effect-fade.js",
    "../src/modules/effect-cube/effect-cube.js",
    "../src/modules/effect-flip/effect-flip.js",
    "../src/modules/effect-coverflow/effect-coverflow.js",
    "../src/modules/effect-creative/effect-creative.js",
    "../src/modules/effect-cards/effect-cards.js"
    ],
    names: [
    "isObject",
    "obj",
    "constructor",
    "Object",
    "extend",
    "target",
    "src",
    "keys",
    "forEach",
    "key",
    "length",
    "ssrDocument",
    "body",
    "addEventListener",
    "removeEventListener",
    "activeElement",
    "blur",
    "nodeName",
    "querySelector",
    "querySelectorAll",
    "getElementById",
    "createEvent",
    "initEvent",
    "createElement",
    "children",
    "childNodes",
    "style",
    "setAttribute",
    "getElementsByTagName",
    "createElementNS",
    "importNode",
    "location",
    "hash",
    "host",
    "hostname",
    "href",
    "origin",
    "pathname",
    "protocol",
    "search",
    "getDocument",
    "doc",
    "document",
    "ssrWindow",
    "navigator",
    "userAgent",
    "history",
    "replaceState",
    "pushState",
    "go",
    "back",
    "CustomEvent",
    "this",
    "getComputedStyle",
    "getPropertyValue",
    "Image",
    "Date",
    "screen",
    "setTimeout",
    "clearTimeout",
    "matchMedia",
    "requestAnimationFrame",
    "callback",
    "cancelAnimationFrame",
    "id",
    "getWindow",
    "win",
    "window",
    "Dom7",
    "Array",
    "items",
    "super",
    "proto",
    "__proto__",
    "defineProperty",
    "get",
    "set",
    "value",
    "makeReactive",
    "arrayFlat",
    "arr",
    "res",
    "el",
    "isArray",
    "push",
    "arrayFilter",
    "prototype",
    "filter",
    "call",
    "$",
    "selector",
    "context",
    "html",
    "trim",
    "indexOf",
    "toCreate",
    "tempParent",
    "innerHTML",
    "i",
    "a",
    "qsa",
    "nodeType",
    "uniqueArray",
    "arrayUnique",
    "fn",
    "Methods",
    "addClass",
    "_len",
    "arguments",
    "classes",
    "_key",
    "classNames",
    "map",
    "c",
    "split",
    "classList",
    "add",
    "removeClass",
    "_len2",
    "_key2",
    "remove",
    "hasClass",
    "_len4",
    "_key4",
    "className",
    "contains",
    "toggleClass",
    "_len3",
    "_key3",
    "toggle",
    "attr",
    "attrs",
    "getAttribute",
    "attrName",
    "removeAttr",
    "removeAttribute",
    "transform",
    "transition",
    "duration",
    "transitionDuration",
    "on",
    "_len5",
    "args",
    "_key5",
    "eventType",
    "targetSelector",
    "listener",
    "capture",
    "handleLiveEvent",
    "e",
    "eventData",
    "dom7EventData",
    "unshift",
    "is",
    "apply",
    "parents",
    "k",
    "handleEvent",
    "undefined",
    "events",
    "j",
    "event",
    "dom7LiveListeners",
    "proxyListener",
    "dom7Listeners",
    "off",
    "_len6",
    "_key6",
    "handlers",
    "handler",
    "dom7proxy",
    "splice",
    "trigger",
    "_len9",
    "_key9",
    "evt",
    "detail",
    "bubbles",
    "cancelable",
    "data",
    "dataIndex",
    "dispatchEvent",
    "transitionEnd",
    "dom",
    "fireCallBack",
    "outerWidth",
    "includeMargins",
    "styles",
    "offsetWidth",
    "parseFloat",
    "outerHeight",
    "offsetHeight",
    "offset",
    "box",
    "getBoundingClientRect",
    "clientTop",
    "clientLeft",
    "scrollTop",
    "scrollY",
    "scrollLeft",
    "scrollX",
    "top",
    "left",
    "css",
    "props",
    "prop",
    "each",
    "index",
    "text",
    "textContent",
    "compareWith",
    "matches",
    "webkitMatchesSelector",
    "msMatchesSelector",
    "child",
    "previousSibling",
    "eq",
    "returnIndex",
    "append",
    "newChild",
    "tempDiv",
    "firstChild",
    "appendChild",
    "prepend",
    "insertBefore",
    "next",
    "nextElementSibling",
    "nextAll",
    "nextEls",
    "prev",
    "previousElementSibling",
    "prevAll",
    "prevEls",
    "parent",
    "parentNode",
    "closest",
    "find",
    "foundElements",
    "found",
    "removeChild",
    "nextTick",
    "delay",
    "now",
    "getTranslate",
    "axis",
    "matrix",
    "curTransform",
    "transformMatrix",
    "curStyle",
    "currentStyle",
    "WebKitCSSMatrix",
    "webkitTransform",
    "replace",
    "join",
    "MozTransform",
    "OTransform",
    "MsTransform",
    "msTransform",
    "toString",
    "m41",
    "m42",
    "o",
    "slice",
    "isNode",
    "node",
    "HTMLElement",
    "to",
    "noExtend",
    "nextSource",
    "keysArray",
    "nextIndex",
    "len",
    "nextKey",
    "desc",
    "getOwnPropertyDescriptor",
    "enumerable",
    "__swiper__",
    "setCSSProperty",
    "varName",
    "varValue",
    "setProperty",
    "animateCSSModeScroll",
    "_ref",
    "swiper",
    "targetPosition",
    "side",
    "startPosition",
    "translate",
    "time",
    "startTime",
    "params",
    "speed",
    "wrapperEl",
    "scrollSnapType",
    "cssModeFrameID",
    "dir",
    "isOutOfBound",
    "current",
    "animate",
    "getTime",
    "progress",
    "Math",
    "max",
    "min",
    "easeProgress",
    "cos",
    "PI",
    "currentPosition",
    "scrollTo",
    "overflow",
    "support",
    "deviceCached",
    "browser",
    "getSupport",
    "smoothScroll",
    "documentElement",
    "touch",
    "DocumentTouch",
    "passiveListener",
    "supportsPassive",
    "opts",
    "gestures",
    "calcSupport",
    "getDevice",
    "overrides",
    "_temp",
    "platform",
    "ua",
    "device",
    "ios",
    "android",
    "screenWidth",
    "width",
    "screenHeight",
    "height",
    "match",
    "ipad",
    "ipod",
    "iphone",
    "windows",
    "macos",
    "os",
    "calcDevice",
    "getBrowser",
    "isSafari",
    "toLowerCase",
    "isWebView",
    "test",
    "calcBrowser",
    "methodName",
    "writable",
    "eventsEmitter",
    "priority",
    "self",
    "method",
    "eventsListeners",
    "once",
    "onceHandler",
    "__emitterProxy",
    "onAny",
    "eventsAnyListeners",
    "offAny",
    "eventHandler",
    "emit",
    "update",
    "updateSize",
    "$el",
    "clientWidth",
    "clientHeight",
    "isHorizontal",
    "isVertical",
    "parseInt",
    "Number",
    "isNaN",
    "assign",
    "size",
    "updateSlides",
    "getDirectionLabel",
    "property",
    "marginRight",
    "getDirectionPropertyValue",
    "label",
    "$wrapperEl",
    "swiperSize",
    "rtlTranslate",
    "rtl",
    "wrongRTL",
    "isVirtual",
    "virtual",
    "enabled",
    "previousSlidesLength",
    "slides",
    "slideClass",
    "slidesLength",
    "snapGrid",
    "slidesGrid",
    "slidesSizesGrid",
    "offsetBefore",
    "slidesOffsetBefore",
    "offsetAfter",
    "slidesOffsetAfter",
    "previousSnapGridLength",
    "previousSlidesGridLength",
    "spaceBetween",
    "slidePosition",
    "prevSlideSize",
    "virtualSize",
    "marginLeft",
    "marginBottom",
    "marginTop",
    "centeredSlides",
    "cssMode",
    "gridEnabled",
    "grid",
    "rows",
    "slideSize",
    "initSlides",
    "shouldResetSlideSize",
    "slidesPerView",
    "breakpoints",
    "slide",
    "updateSlide",
    "slideStyles",
    "currentTransform",
    "currentWebKitTransform",
    "roundLengths",
    "paddingLeft",
    "paddingRight",
    "boxSizing",
    "floor",
    "swiperSlideSize",
    "abs",
    "slidesPerGroup",
    "slidesPerGroupSkip",
    "effect",
    "setWrapperSize",
    "updateWrapperSize",
    "newSlidesGrid",
    "slidesGridItem",
    "_",
    "slideIndex",
    "centeredSlidesBounds",
    "allSlidesSize",
    "slideSizeValue",
    "maxSnap",
    "snap",
    "centerInsufficientSlides",
    "allSlidesOffset",
    "snapIndex",
    "addToSnapGrid",
    "addToSlidesGrid",
    "v",
    "watchOverflow",
    "checkOverflow",
    "watchSlidesProgress",
    "updateSlidesOffset",
    "backFaceHiddenClass",
    "containerModifierClass",
    "hasClassBackfaceClassAdded",
    "maxBackfaceHiddenSlides",
    "updateAutoHeight",
    "activeSlides",
    "newHeight",
    "setTransition",
    "getSlideByIndex",
    "visibleSlides",
    "ceil",
    "activeIndex",
    "swiperSlideOffset",
    "offsetLeft",
    "offsetTop",
    "updateSlidesProgress",
    "offsetCenter",
    "slideVisibleClass",
    "visibleSlidesIndexes",
    "slideOffset",
    "slideProgress",
    "minTranslate",
    "originalSlideProgress",
    "slideBefore",
    "slideAfter",
    "originalProgress",
    "updateProgress",
    "multiplier",
    "translatesDiff",
    "maxTranslate",
    "isBeginning",
    "isEnd",
    "wasBeginning",
    "wasEnd",
    "autoHeight",
    "updateSlidesClasses",
    "realIndex",
    "activeSlide",
    "slideActiveClass",
    "slideNextClass",
    "slidePrevClass",
    "slideDuplicateActiveClass",
    "slideDuplicateNextClass",
    "slideDuplicatePrevClass",
    "loop",
    "slideDuplicateClass",
    "nextSlide",
    "prevSlide",
    "emitSlidesClasses",
    "updateActiveIndex",
    "newActiveIndex",
    "previousIndex",
    "previousRealIndex",
    "previousSnapIndex",
    "normalizeSlideIndex",
    "skip",
    "initialized",
    "runCallbacksOnInit",
    "updateClickedSlide",
    "slideFound",
    "clickedSlide",
    "clickedIndex",
    "slideToClickedSlide",
    "virtualTranslate",
    "currentTranslate",
    "setTranslate",
    "byController",
    "newProgress",
    "x",
    "y",
    "previousTranslate",
    "translateTo",
    "runCallbacks",
    "translateBounds",
    "internal",
    "animating",
    "preventInteractionOnTransition",
    "newTranslate",
    "isH",
    "behavior",
    "onTranslateToWrapperTransitionEnd",
    "destroyed",
    "transitionEmit",
    "direction",
    "step",
    "slideTo",
    "initial",
    "Error",
    "indexAsNumber",
    "isFinite",
    "initialSlide",
    "normalizedTranslate",
    "normalizedGrid",
    "normalizedGridNext",
    "allowSlideNext",
    "allowSlidePrev",
    "transitionStart",
    "t",
    "_immediateVirtual",
    "_swiperImmediateVirtual",
    "onSlideToWrapperTransitionEnd",
    "slideToLoop",
    "newIndex",
    "loopedSlides",
    "slideNext",
    "perGroup",
    "slidesPerGroupAuto",
    "slidesPerViewDynamic",
    "increment",
    "loopPreventsSlide",
    "loopFix",
    "_clientLeft",
    "rewind",
    "slidePrev",
    "normalize",
    "val",
    "normalizedSnapGrid",
    "prevSnap",
    "prevSnapIndex",
    "prevIndex",
    "lastIndex",
    "slideReset",
    "slideToClosest",
    "threshold",
    "currentSnap",
    "slideToIndex",
    "loopCreate",
    "$selector",
    "loopFillGroupWithBlank",
    "blankSlidesNum",
    "blankNode",
    "slideBlankClass",
    "loopAdditionalSlides",
    "prependSlides",
    "appendSlides",
    "cloneNode",
    "diff",
    "loopDestroy",
    "onTouchStart",
    "touchEventsData",
    "touches",
    "originalEvent",
    "$targetEl",
    "touchEventsTarget",
    "isTouchEvent",
    "type",
    "which",
    "button",
    "isTouched",
    "isMoved",
    "noSwipingClass",
    "shadowRoot",
    "path",
    "noSwipingSelector",
    "isTargetShadow",
    "noSwiping",
    "base",
    "__closestFrom",
    "assignedSlot",
    "getRootNode",
    "closestElement",
    "allowClick",
    "swipeHandler",
    "currentX",
    "targetTouches",
    "pageX",
    "currentY",
    "pageY",
    "startX",
    "startY",
    "edgeSwipeDetection",
    "iOSEdgeSwipeDetection",
    "edgeSwipeThreshold",
    "iOSEdgeSwipeThreshold",
    "innerWidth",
    "preventDefault",
    "allowTouchCallbacks",
    "isScrolling",
    "startMoving",
    "touchStartTime",
    "swipeDirection",
    "allowThresholdMove",
    "focusableElements",
    "shouldPreventDefault",
    "allowTouchMove",
    "touchStartPreventDefault",
    "touchStartForcePreventDefault",
    "isContentEditable",
    "freeMode",
    "onTouchMove",
    "targetTouch",
    "changedTouches",
    "preventedByNestedSwiper",
    "touchReleaseOnEdges",
    "diffX",
    "diffY",
    "sqrt",
    "touchAngle",
    "atan2",
    "touchMoveStopPropagation",
    "nested",
    "stopPropagation",
    "startTranslate",
    "allowMomentumBounce",
    "grabCursor",
    "setGrabCursor",
    "touchRatio",
    "disableParentSwiper",
    "resistanceRatio",
    "resistance",
    "followFinger",
    "onTouchEnd",
    "touchEndTime",
    "timeDiff",
    "pathTree",
    "composedPath",
    "lastClickTime",
    "currentPos",
    "stopIndex",
    "groupSize",
    "rewindFirstIndex",
    "rewindLastIndex",
    "ratio",
    "longSwipesMs",
    "longSwipes",
    "longSwipesRatio",
    "shortSwipes",
    "navigation",
    "nextEl",
    "prevEl",
    "onResize",
    "setBreakpoint",
    "autoplay",
    "running",
    "paused",
    "run",
    "onClick",
    "preventClicks",
    "preventClicksPropagation",
    "stopImmediatePropagation",
    "onScroll",
    "dummyEventAttached",
    "dummyEventListener",
    "touchEvents",
    "domMethod",
    "swiperMethod",
    "start",
    "passiveListeners",
    "passive",
    "move",
    "end",
    "cancel",
    "updateOnWindowResize",
    "events$1",
    "attachEvents",
    "bind",
    "detachEvents",
    "isGridEnabled",
    "addClasses",
    "suffixes",
    "entries",
    "prefix",
    "resultClasses",
    "item",
    "prepareClasses",
    "autoheight",
    "fill",
    "centered",
    "emitContainerClasses",
    "removeClasses",
    "defaults",
    "init",
    "resizeObserver",
    "createElements",
    "url",
    "breakpointsBase",
    "simulateTouch",
    "uniqueNavElements",
    "preloadImages",
    "updateOnImagesReady",
    "wrapperClass",
    "_emitClasses",
    "moduleExtendParams",
    "allModulesParams",
    "moduleParamName",
    "moduleParams",
    "auto",
    "prototypes",
    "moving",
    "isLocked",
    "cursor",
    "unsetGrabCursor",
    "breakpoint",
    "getBreakpoint",
    "currentBreakpoint",
    "breakpointParams",
    "originalParams",
    "wasMultiRow",
    "isMultiRow",
    "wasEnabled",
    "directionChanged",
    "needsReLoop",
    "changeDirection",
    "isEnabled",
    "disable",
    "enable",
    "containerEl",
    "currentHeight",
    "innerHeight",
    "points",
    "point",
    "minRatio",
    "substr",
    "sort",
    "b",
    "wasLocked",
    "lastSlideIndex",
    "lastSlideRightEdge",
    "images",
    "loadImage",
    "imageEl",
    "srcset",
    "sizes",
    "checkForComplete",
    "image",
    "onReady",
    "complete",
    "onload",
    "onerror",
    "imagesLoaded",
    "imagesToLoad",
    "currentSrc",
    "extendedDefaults",
    "Swiper",
    "swipers",
    "newParams",
    "modules",
    "__modules__",
    "mod",
    "extendParams",
    "swiperParams",
    "passedParams",
    "eventName",
    "velocity",
    "desktop",
    "touchEventsTouch",
    "touchEventsDesktop",
    "clickTimeout",
    "velocities",
    "setProgress",
    "cls",
    "getSlideClasses",
    "slideEl",
    "updates",
    "view",
    "exact",
    "spv",
    "breakLoop",
    "translateValue",
    "translated",
    "newDirection",
    "needUpdate",
    "currentDirection",
    "mount",
    "mounted",
    "getWrapperSelector",
    "options",
    "getWrapper",
    "wrapper",
    "destroy",
    "deleteInstance",
    "cleanStyles",
    "object",
    "deleteProps",
    "static",
    "newDefaults",
    "module",
    "m",
    "installModule",
    "createElementIfNotDefined",
    "checkProps",
    "element",
    "classesToSelector",
    "appendSlide",
    "observer",
    "prependSlide",
    "addSlide",
    "activeIndexBuffer",
    "baseLength",
    "slidesBuffer",
    "currentSlide",
    "removeSlide",
    "slidesIndexes",
    "indexToRemove",
    "removeAllSlides",
    "effectInit",
    "overwriteParams",
    "perspective",
    "requireUpdateOnVirtual",
    "overwriteParamsResult",
    "_s",
    "effectTarget",
    "effectParams",
    "$slideEl",
    "transformEl",
    "effectVirtualTransitionEnd",
    "allSlides",
    "$transitionEndTarget",
    "eventTriggered",
    "triggerEvents",
    "createShadow",
    "shadowClass",
    "$shadowContainer",
    "$shadowEl",
    "prototypeGroup",
    "protoMethod",
    "use",
    "animationFrame",
    "resizeHandler",
    "orientationChangeHandler",
    "ResizeObserver",
    "newWidth",
    "_ref2",
    "contentBoxSize",
    "contentRect",
    "inlineSize",
    "blockSize",
    "observe",
    "unobserve",
    "observers",
    "attach",
    "MutationObserver",
    "WebkitMutationObserver",
    "mutations",
    "observerUpdate",
    "attributes",
    "childList",
    "characterData",
    "observeParents",
    "observeSlideChildren",
    "containerParents",
    "disconnect",
    "cssModeTimeout",
    "renderSlide",
    "cache",
    "force",
    "addSlidesBefore",
    "addSlidesAfter",
    "from",
    "previousFrom",
    "previousTo",
    "previousSlidesGrid",
    "previousOffset",
    "offsetProp",
    "slidesAfter",
    "slidesBefore",
    "onRendered",
    "lazy",
    "load",
    "renderExternal",
    "slidesToRender",
    "renderExternalUpdate",
    "prependIndexes",
    "appendIndexes",
    "numberOfNewSlides",
    "newCache",
    "cachedIndex",
    "$cachedEl",
    "cachedElIndex",
    "handle",
    "kc",
    "keyCode",
    "charCode",
    "pageUpDown",
    "keyboard",
    "isPageUp",
    "isPageDown",
    "isArrowLeft",
    "isArrowRight",
    "isArrowUp",
    "isArrowDown",
    "shiftKey",
    "altKey",
    "ctrlKey",
    "metaKey",
    "onlyInViewport",
    "inView",
    "swiperWidth",
    "swiperHeight",
    "windowWidth",
    "windowHeight",
    "swiperOffset",
    "swiperCoord",
    "returnValue",
    "timeout",
    "mousewheel",
    "releaseOnEdges",
    "invert",
    "forceToAxis",
    "sensitivity",
    "eventsTarget",
    "thresholdDelta",
    "thresholdTime",
    "lastEventBeforeSnap",
    "lastScrollTime",
    "recentWheelEvents",
    "handleMouseEnter",
    "mouseEntered",
    "handleMouseLeave",
    "animateSlider",
    "newEvent",
    "delta",
    "raw",
    "rtlFactor",
    "sX",
    "sY",
    "pX",
    "pY",
    "wheelDelta",
    "wheelDeltaY",
    "wheelDeltaX",
    "HORIZONTAL_AXIS",
    "deltaY",
    "deltaX",
    "deltaMode",
    "spinX",
    "spinY",
    "pixelX",
    "pixelY",
    "positions",
    "sign",
    "ignoreWheelEvents",
    "position",
    "sticky",
    "shift",
    "prevEvent",
    "firstEvent",
    "snapToThreshold",
    "autoplayDisableOnInteraction",
    "stop",
    "releaseScroll",
    "getEl",
    "toggleEl",
    "disabled",
    "disabledClass",
    "tagName",
    "lockClass",
    "$nextEl",
    "$prevEl",
    "onPrevClick",
    "onNextClick",
    "hideOnClick",
    "hiddenClass",
    "targetEl",
    "pagination",
    "clickable",
    "isHidden",
    "pfx",
    "bulletSize",
    "bulletElement",
    "renderBullet",
    "renderProgressbar",
    "renderFraction",
    "renderCustom",
    "progressbarOpposite",
    "dynamicBullets",
    "dynamicMainBullets",
    "formatFractionCurrent",
    "number",
    "formatFractionTotal",
    "bulletClass",
    "bulletActiveClass",
    "modifierClass",
    "currentClass",
    "totalClass",
    "progressbarFillClass",
    "progressbarOppositeClass",
    "clickableClass",
    "horizontalClass",
    "verticalClass",
    "bullets",
    "dynamicBulletIndex",
    "isPaginationDisabled",
    "setSideBullets",
    "$bulletEl",
    "total",
    "paginationType",
    "firstIndex",
    "midIndex",
    "suffix",
    "bullet",
    "$bullet",
    "bulletIndex",
    "$firstDisplayedBullet",
    "$lastDisplayedBullet",
    "dynamicBulletsLength",
    "bulletsOffset",
    "progressbarDirection",
    "scale",
    "scaleX",
    "scaleY",
    "render",
    "paginationHTML",
    "numberOfBullets",
    "dragStartPos",
    "dragSize",
    "trackSize",
    "divider",
    "dragTimeout",
    "scrollbar",
    "$dragEl",
    "newSize",
    "newPos",
    "hide",
    "opacity",
    "display",
    "getPointerPosition",
    "clientX",
    "clientY",
    "setDragPosition",
    "positionRatio",
    "onDragStart",
    "onDragMove",
    "onDragEnd",
    "snapOnRelease",
    "activeListener",
    "eventMethod",
    "$swiperEl",
    "dragClass",
    "dragEl",
    "draggable",
    "parallax",
    "setTransform",
    "p",
    "currentOpacity",
    "currentScale",
    "_swiper",
    "parallaxEl",
    "$parallaxEl",
    "parallaxDuration",
    "zoom",
    "maxRatio",
    "containerClass",
    "zoomedSlideClass",
    "gesturesEnabled",
    "fakeGestureTouched",
    "fakeGestureMoved",
    "isScaling",
    "gesture",
    "slideWidth",
    "slideHeight",
    "$imageEl",
    "$imageWrapEl",
    "minX",
    "minY",
    "maxX",
    "maxY",
    "touchesStart",
    "touchesCurrent",
    "prevPositionX",
    "prevPositionY",
    "prevTime",
    "getDistanceBetweenTouches",
    "x1",
    "y1",
    "x2",
    "y2",
    "onGestureStart",
    "scaleStart",
    "onGestureChange",
    "scaleMove",
    "onGestureEnd",
    "scaledWidth",
    "scaledHeight",
    "onTransitionEnd",
    "zoomIn",
    "touchX",
    "touchY",
    "offsetX",
    "offsetY",
    "translateX",
    "translateY",
    "imageWidth",
    "imageHeight",
    "translateMinX",
    "translateMinY",
    "translateMaxX",
    "translateMaxY",
    "touchAction",
    "zoomOut",
    "zoomToggle",
    "getListeners",
    "activeListenerWithCapture",
    "getSlideSelector",
    "toggleGestures",
    "slideSelector",
    "enableGestures",
    "disableGestures",
    "momentumDurationX",
    "momentumDurationY",
    "momentumDistanceX",
    "newPositionX",
    "momentumDistanceY",
    "newPositionY",
    "momentumDuration",
    "in",
    "out",
    "checkInView",
    "loadPrevNext",
    "loadPrevNextAmount",
    "loadOnTransitionStart",
    "scrollingElement",
    "elementClass",
    "loadingClass",
    "loadedClass",
    "preloaderClass",
    "scrollHandlerAttached",
    "initialImageLoaded",
    "loadInSlide",
    "loadInDuplicate",
    "$images",
    "background",
    "$pictureEl",
    "sourceEl",
    "$source",
    "slideOriginalIndex",
    "slideExist",
    "amount",
    "maxIndex",
    "minIndex",
    "checkInViewOnLoad",
    "$scrollElement",
    "isWindow",
    "scrollElementWidth",
    "scrollElementHeight",
    "LinearSpline",
    "binarySearch",
    "guess",
    "array",
    "i1",
    "i3",
    "interpolate",
    "removeSpline",
    "controller",
    "control",
    "spline",
    "inverse",
    "by",
    "_t",
    "controlled",
    "controlledTranslate",
    "setControlledTranslate",
    "getInterpolateFunction",
    "setControlledTransition",
    "a11y",
    "notificationClass",
    "prevSlideMessage",
    "nextSlideMessage",
    "firstSlideMessage",
    "lastSlideMessage",
    "paginationBulletMessage",
    "slideLabelMessage",
    "containerMessage",
    "containerRoleDescriptionMessage",
    "itemRoleDescriptionMessage",
    "slideRole",
    "liveRegion",
    "notify",
    "message",
    "notification",
    "makeElFocusable",
    "makeElNotFocusable",
    "addElRole",
    "role",
    "addElRoleDescription",
    "description",
    "addElLabel",
    "disableEl",
    "enableEl",
    "onEnterOrSpaceKey",
    "click",
    "hasPagination",
    "hasClickablePagination",
    "initNavEl",
    "wrapperId",
    "controls",
    "addElControls",
    "handleFocus",
    "includes",
    "isActive",
    "isVisible",
    "$containerEl",
    "repeat",
    "round",
    "random",
    "live",
    "addElLive",
    "updateNavigation",
    "bulletEl",
    "updatePagination",
    "root",
    "paths",
    "slugify",
    "getPathValues",
    "urlOverride",
    "URL",
    "pathArray",
    "part",
    "setHistory",
    "currentState",
    "state",
    "scrollToSlide",
    "setHistoryPopState",
    "hashNavigation",
    "watchState",
    "onHashChange",
    "newHash",
    "setHash",
    "$activeSlideEl",
    "autoplayResult",
    "reverseDirection",
    "stopOnLastSlide",
    "pause",
    "waitForTransition",
    "onVisibilityChange",
    "visibilityState",
    "onMouseEnter",
    "disableOnInteraction",
    "onMouseLeave",
    "pauseOnMouseEnter",
    "thumbs",
    "multipleActiveThumbs",
    "autoScrollOffset",
    "slideThumbActiveClass",
    "thumbsContainerClass",
    "swiperCreated",
    "onThumbClick",
    "thumbsSwiper",
    "currentIndex",
    "thumbsParams",
    "SwiperClass",
    "thumbsSwiperParams",
    "useOffset",
    "newThumbsIndex",
    "currentThumbsIndex",
    "prevThumbsIndex",
    "nextThumbsIndex",
    "thumbsToActivate",
    "thumbActiveClass",
    "momentum",
    "momentumRatio",
    "momentumBounce",
    "momentumBounceRatio",
    "momentumVelocityRatio",
    "minimumVelocity",
    "lastMoveEvent",
    "pop",
    "velocityEvent",
    "distance",
    "momentumDistance",
    "newPosition",
    "afterBouncePosition",
    "doBounce",
    "bounceAmount",
    "needsLoopFix",
    "moveDistance",
    "currentSlideSize",
    "slidesNumberEvenToRows",
    "slidesPerRow",
    "numFullColumns",
    "newSlideOrderIndex",
    "column",
    "row",
    "groupIndex",
    "slideIndexInGroup",
    "columnsInGroup",
    "order",
    "fadeEffect",
    "crossFade",
    "tx",
    "ty",
    "slideOpacity",
    "cubeEffect",
    "slideShadows",
    "shadow",
    "shadowOffset",
    "shadowScale",
    "$cubeShadowEl",
    "wrapperRotate",
    "slideAngle",
    "tz",
    "shadowBefore",
    "shadowAfter",
    "shadowAngle",
    "sin",
    "scale1",
    "scale2",
    "zFactor",
    "flipEffect",
    "limitRotation",
    "rotateY",
    "rotateX",
    "zIndex",
    "coverflowEffect",
    "rotate",
    "stretch",
    "depth",
    "modifier",
    "center",
    "centerOffset",
    "offsetMultiplier",
    "translateZ",
    "slideTransform",
    "$shadowBeforeEl",
    "$shadowAfterEl",
    "creativeEffect",
    "limitProgress",
    "shadowPerProgress",
    "progressMultiplier",
    "getTranslateValue",
    "isCenteredSlides",
    "margin",
    "r",
    "custom",
    "translateString",
    "rotateString",
    "scaleString",
    "opacityString",
    "shadowOpacity",
    "cardsEffect",
    "tX",
    "tY",
    "tZ",
    "tXAdd",
    "isSwipeToNext",
    "isSwipeToPrev",
    "subProgress",
    "prevY"
    ],
    mappings: "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",
    file: "swiper-bundle.min.js",
    sourcesContent: [
    "/**
     * SSR Window 4.0.2
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: December 13, 2021
     */
    /* eslint-disable no-param-reassign */
    function isObject(obj) {
        return (obj !== null &&
            typeof obj === 'object' &&
            'constructor' in obj &&
            obj.constructor === Object);
    }
    function extend(target = {}, src = {}) {
        Object.keys(src).forEach((key) => {
            if (typeof target[key] === 'undefined')
                target[key] = src[key];
            else if (isObject(src[key]) &&
                isObject(target[key]) &&
                Object.keys(src[key]).length > 0) {
                extend(target[key], src[key]);
            }
        });
    }
    
    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: '',
        },
        querySelector() {
            return null;
        },
        querySelectorAll() {
            return [];
        },
        getElementById() {
            return null;
        },
        createEvent() {
            return {
                initEvent() { },
            };
        },
        createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute() { },
                getElementsByTagName() {
                    return [];
                },
            };
        },
        createElementNS() {
            return {};
        },
        importNode() {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
    };
    function getDocument() {
        const doc = typeof document !== 'undefined' ? document : {};
        extend(doc, ssrDocument);
        return doc;
    }
    
    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: '',
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { },
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle() {
            return {
                getPropertyValue() {
                    return '';
                },
            };
        },
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia() {
            return {};
        },
        requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        },
    };
    function getWindow() {
        const win = typeof window !== 'undefined' ? window : {};
        extend(win, ssrWindow);
        return win;
    }
    
    export { extend, getDocument, getWindow, ssrDocument, ssrWindow };
    ",
    "/**
     * Dom7 4.0.4
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2022, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: January 11, 2022
     */
    import { getWindow, getDocument } from 'ssr-window';
    
    /* eslint-disable no-proto */
    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get() {
          return proto;
        },
    
        set(value) {
          proto.__proto__ = value;
        }
    
      });
    }
    
    class Dom7 extends Array {
      constructor(items) {
        if (typeof items === 'number') {
          super(items);
        } else {
          super(...(items || []));
          makeReactive(this);
        }
      }
    
    }
    
    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach(el => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      const uniqueArray = [];
    
      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }
    
      return uniqueArray;
    }
    function toCamelCase(string) {
      return string.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase());
    }
    
    // eslint-disable-next-line
    
    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }
    
      const a = [];
      const res = context.querySelectorAll(selector);
    
      for (let i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }
    
      return a;
    }
    
    function $(selector, context) {
      const window = getWindow();
      const document = getDocument();
      let arr = [];
    
      if (!context && selector instanceof Dom7) {
        return selector;
      }
    
      if (!selector) {
        return new Dom7(arr);
      }
    
      if (typeof selector === 'string') {
        const html = selector.trim();
    
        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          const tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;
    
          for (let i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);
    
      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }
    
      return new Dom7(arrayUnique(arr));
    }
    
    $.fn = Dom7.prototype;
    
    // eslint-disable-next-line
    
    function addClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.add(...classNames);
      });
      return this;
    }
    
    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.remove(...classNames);
      });
      return this;
    }
    
    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        classNames.forEach(className => {
          el.classList.toggle(className);
        });
      });
    }
    
    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      return arrayFilter(this, el => {
        return classNames.filter(className => el.classList.contains(className)).length > 0;
      }).length > 0;
    }
    
    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs
    
    
      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }
    
      return this;
    }
    
    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }
    
      return this;
    }
    
    function prop(props, value) {
      if (arguments.length === 1 && typeof props === 'string') {
        // Get prop
        if (this[0]) return this[0][props];
      } else {
        // Set props
        for (let i = 0; i < this.length; i += 1) {
          if (arguments.length === 2) {
            // String
            this[i][props] = value;
          } else {
            // Object
            for (const propName in props) {
              this[i][propName] = props[propName];
            }
          }
        }
    
        return this;
      }
    
      return this;
    }
    
    function data(key, value) {
      let el;
    
      if (typeof value === 'undefined') {
        el = this[0];
        if (!el) return undefined; // Get value
    
        if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
          return el.dom7ElementDataStorage[key];
        }
    
        const dataKey = el.getAttribute(`data-${key}`);
    
        if (dataKey) {
          return dataKey;
        }
    
        return undefined;
      } // Set value
    
    
      for (let i = 0; i < this.length; i += 1) {
        el = this[i];
        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
        el.dom7ElementDataStorage[key] = value;
      }
    
      return this;
    }
    
    function removeData(key) {
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
    
        if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
          el.dom7ElementDataStorage[key] = null;
          delete el.dom7ElementDataStorage[key];
        }
      }
    }
    
    function dataset() {
      const el = this[0];
      if (!el) return undefined;
      const dataset = {}; // eslint-disable-line
    
      if (el.dataset) {
        for (const dataKey in el.dataset) {
          dataset[dataKey] = el.dataset[dataKey];
        }
      } else {
        for (let i = 0; i < el.attributes.length; i += 1) {
          const attr = el.attributes[i];
    
          if (attr.name.indexOf('data-') >= 0) {
            dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
          }
        }
      }
    
      for (const key in dataset) {
        if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
      }
    
      return dataset;
    }
    
    function val(value) {
      if (typeof value === 'undefined') {
        // get value
        const el = this[0];
        if (!el) return undefined;
    
        if (el.multiple && el.nodeName.toLowerCase() === 'select') {
          const values = [];
    
          for (let i = 0; i < el.selectedOptions.length; i += 1) {
            values.push(el.selectedOptions[i].value);
          }
    
          return values;
        }
    
        return el.value;
      } // set value
    
    
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
    
        if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
          for (let j = 0; j < el.options.length; j += 1) {
            el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
          }
        } else {
          el.value = value;
        }
      }
    
      return this;
    }
    
    function value(value) {
      return this.val(value);
    }
    
    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }
    
      return this;
    }
    
    function transition(duration) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
      }
    
      return this;
    }
    
    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;
    
      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }
    
      if (!capture) capture = false;
    
      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];
    
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
    
        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          const parents = $(target).parents(); // eslint-disable-line
    
          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }
    
      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
    
        listener.apply(this, eventData);
      }
    
      const events = eventType.split(' ');
      let j;
    
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
    
        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }
    
      return this;
    }
    
    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;
    
      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }
    
      if (!capture) capture = false;
      const events = eventType.split(' ');
    
      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];
    
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;
    
          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }
    
          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];
    
              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }
    
      return this;
    }
    
    function once(...args) {
      const dom = this;
      let [eventName, targetSelector, listener, capture] = args;
    
      if (typeof args[1] === 'function') {
        [eventName, listener, capture] = args;
        targetSelector = undefined;
      }
    
      function onceHandler(...eventArgs) {
        listener.apply(this, eventArgs);
        dom.off(eventName, targetSelector, onceHandler, capture);
    
        if (onceHandler.dom7proxy) {
          delete onceHandler.dom7proxy;
        }
      }
    
      onceHandler.dom7proxy = listener;
      return dom.on(eventName, targetSelector, onceHandler, capture);
    }
    
    function trigger(...args) {
      const window = getWindow();
      const events = args[0].split(' ');
      const eventData = args[1];
    
      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];
    
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
    
          if (window.CustomEvent) {
            const evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }
    
      return this;
    }
    
    function transitionEnd(callback) {
      const dom = this;
    
      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }
    
      if (callback) {
        dom.on('transitionend', fireCallBack);
      }
    
      return this;
    }
    
    function animationEnd(callback) {
      const dom = this;
    
      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('animationend', fireCallBack);
      }
    
      if (callback) {
        dom.on('animationend', fireCallBack);
      }
    
      return this;
    }
    
    function width() {
      const window = getWindow();
    
      if (this[0] === window) {
        return window.innerWidth;
      }
    
      if (this.length > 0) {
        return parseFloat(this.css('width'));
      }
    
      return null;
    }
    
    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }
    
        return this[0].offsetWidth;
      }
    
      return null;
    }
    
    function height() {
      const window = getWindow();
    
      if (this[0] === window) {
        return window.innerHeight;
      }
    
      if (this.length > 0) {
        return parseFloat(this.css('height'));
      }
    
      return null;
    }
    
    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }
    
        return this[0].offsetHeight;
      }
    
      return null;
    }
    
    function offset() {
      if (this.length > 0) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = document.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === window ? window.scrollY : el.scrollTop;
        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }
    
      return null;
    }
    
    function hide() {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.display = 'none';
      }
    
      return this;
    }
    
    function show() {
      const window = getWindow();
    
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
    
        if (el.style.display === 'none') {
          el.style.display = '';
        }
    
        if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
          // Still not visible
          el.style.display = 'block';
        }
      }
    
      return this;
    }
    
    function styles() {
      const window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }
    
    function css(props, value) {
      const window = getWindow();
      let i;
    
      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (const prop in props) {
              this[i].style[prop] = props[prop];
            }
          }
    
          return this;
        }
      }
    
      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }
    
        return this;
      }
    
      return this;
    }
    
    function each(callback) {
      if (!callback) return this;
      this.forEach((el, index) => {
        callback.apply(el, [el, index]);
      });
      return this;
    }
    
    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }
    
    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }
    
      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }
    
      return this;
    }
    
    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }
    
      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }
    
      return this;
    }
    
    function is(selector) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;
    
      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);
    
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
    
        return false;
      }
    
      if (selector === document) {
        return el === document;
      }
    
      if (selector === window) {
        return el === window;
      }
    
      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;
    
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
    
        return false;
      }
    
      return false;
    }
    
    function index() {
      let child = this[0];
      let i;
    
      if (child) {
        i = 0; // eslint-disable-next-line
    
        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }
    
        return i;
      }
    
      return undefined;
    }
    
    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;
    
      if (index > length - 1) {
        return $([]);
      }
    
      if (index < 0) {
        const returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }
    
      return $([this[index]]);
    }
    
    function append(...els) {
      let newChild;
      const document = getDocument();
    
      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];
    
        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;
    
            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }
    
      return this;
    }
    
    function appendTo(parent) {
      $(parent).append(this);
      return this;
    }
    
    function prepend(newChild) {
      const document = getDocument();
      let i;
      let j;
    
      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;
    
          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }
    
      return this;
    }
    
    function prependTo(parent) {
      $(parent).prepend(this);
      return this;
    }
    
    function insertBefore(selector) {
      const before = $(selector);
    
      for (let i = 0; i < this.length; i += 1) {
        if (before.length === 1) {
          before[0].parentNode.insertBefore(this[i], before[0]);
        } else if (before.length > 1) {
          for (let j = 0; j < before.length; j += 1) {
            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
          }
        }
      }
    }
    
    function insertAfter(selector) {
      const after = $(selector);
    
      for (let i = 0; i < this.length; i += 1) {
        if (after.length === 1) {
          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
        } else if (after.length > 1) {
          for (let j = 0; j < after.length; j += 1) {
            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
          }
        }
      }
    }
    
    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }
    
          return $([]);
        }
    
        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }
    
      return $([]);
    }
    
    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return $([]);
    
      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line
    
        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);
    
        el = next;
      }
    
      return $(nextEls);
    }
    
    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];
    
        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }
    
          return $([]);
        }
    
        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }
    
      return $([]);
    }
    
    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return $([]);
    
      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line
    
        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);
    
        el = prev;
      }
    
      return $(prevEls);
    }
    
    function siblings(selector) {
      return this.nextAll(selector).add(this.prevAll(selector));
    }
    
    function parent(selector) {
      const parents = []; // eslint-disable-line
    
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }
    
      return $(parents);
    }
    
    function parents(selector) {
      const parents = []; // eslint-disable-line
    
      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line
    
        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }
    
          parent = parent.parentNode;
        }
      }
    
      return $(parents);
    }
    
    function closest(selector) {
      let closest = this; // eslint-disable-line
    
      if (typeof selector === 'undefined') {
        return $([]);
      }
    
      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }
    
      return closest;
    }
    
    function find(selector) {
      const foundElements = [];
    
      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);
    
        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }
    
      return $(foundElements);
    }
    
    function children(selector) {
      const children = []; // eslint-disable-line
    
      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].children;
    
        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }
    
      return $(children);
    }
    
    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }
    
      return this;
    }
    
    function detach() {
      return this.remove();
    }
    
    function add(...els) {
      const dom = this;
      let i;
      let j;
    
      for (i = 0; i < els.length; i += 1) {
        const toAdd = $(els[i]);
    
        for (j = 0; j < toAdd.length; j += 1) {
          dom.push(toAdd[j]);
        }
      }
    
      return dom;
    }
    
    function empty() {
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
    
        if (el.nodeType === 1) {
          for (let j = 0; j < el.childNodes.length; j += 1) {
            if (el.childNodes[j].parentNode) {
              el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
            }
          }
    
          el.textContent = '';
        }
      }
    
      return this;
    }
    
    // eslint-disable-next-line
    
    function scrollTo(...args) {
      const window = getWindow();
      let [left, top, duration, easing, callback] = args;
    
      if (args.length === 4 && typeof easing === 'function') {
        callback = easing;
        [left, top, duration, callback, easing] = args;
      }
    
      if (typeof easing === 'undefined') easing = 'swing';
      return this.each(function animate() {
        const el = this;
        let currentTop;
        let currentLeft;
        let maxTop;
        let maxLeft;
        let newTop;
        let newLeft;
        let scrollTop; // eslint-disable-line
    
        let scrollLeft; // eslint-disable-line
    
        let animateTop = top > 0 || top === 0;
        let animateLeft = left > 0 || left === 0;
    
        if (typeof easing === 'undefined') {
          easing = 'swing';
        }
    
        if (animateTop) {
          currentTop = el.scrollTop;
    
          if (!duration) {
            el.scrollTop = top;
          }
        }
    
        if (animateLeft) {
          currentLeft = el.scrollLeft;
    
          if (!duration) {
            el.scrollLeft = left;
          }
        }
    
        if (!duration) return;
    
        if (animateTop) {
          maxTop = el.scrollHeight - el.offsetHeight;
          newTop = Math.max(Math.min(top, maxTop), 0);
        }
    
        if (animateLeft) {
          maxLeft = el.scrollWidth - el.offsetWidth;
          newLeft = Math.max(Math.min(left, maxLeft), 0);
        }
    
        let startTime = null;
        if (animateTop && newTop === currentTop) animateTop = false;
        if (animateLeft && newLeft === currentLeft) animateLeft = false;
    
        function render(time = new Date().getTime()) {
          if (startTime === null) {
            startTime = time;
          }
    
          const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
          const easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
          let done;
          if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
          if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);
    
          if (animateTop && newTop > currentTop && scrollTop >= newTop) {
            el.scrollTop = newTop;
            done = true;
          }
    
          if (animateTop && newTop < currentTop && scrollTop <= newTop) {
            el.scrollTop = newTop;
            done = true;
          }
    
          if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }
    
          if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
            el.scrollLeft = newLeft;
            done = true;
          }
    
          if (done) {
            if (callback) callback();
            return;
          }
    
          if (animateTop) el.scrollTop = scrollTop;
          if (animateLeft) el.scrollLeft = scrollLeft;
          window.requestAnimationFrame(render);
        }
    
        window.requestAnimationFrame(render);
      });
    } // scrollTop(top, duration, easing, callback) {
    
    
    function scrollTop(...args) {
      let [top, duration, easing, callback] = args;
    
      if (args.length === 3 && typeof easing === 'function') {
        [top, duration, callback, easing] = args;
      }
    
      const dom = this;
    
      if (typeof top === 'undefined') {
        if (dom.length > 0) return dom[0].scrollTop;
        return null;
      }
    
      return dom.scrollTo(undefined, top, duration, easing, callback);
    }
    
    function scrollLeft(...args) {
      let [left, duration, easing, callback] = args;
    
      if (args.length === 3 && typeof easing === 'function') {
        [left, duration, callback, easing] = args;
      }
    
      const dom = this;
    
      if (typeof left === 'undefined') {
        if (dom.length > 0) return dom[0].scrollLeft;
        return null;
      }
    
      return dom.scrollTo(left, undefined, duration, easing, callback);
    }
    
    // eslint-disable-next-line
    
    function animate(initialProps, initialParams) {
      const window = getWindow();
      const els = this;
      const a = {
        props: Object.assign({}, initialProps),
        params: Object.assign({
          duration: 300,
          easing: 'swing' // or 'linear'
    
          /* Callbacks
          begin(elements)
          complete(elements)
          progress(elements, complete, remaining, start, tweenValue)
          */
    
        }, initialParams),
        elements: els,
        animating: false,
        que: [],
    
        easingProgress(easing, progress) {
          if (easing === 'swing') {
            return 0.5 - Math.cos(progress * Math.PI) / 2;
          }
    
          if (typeof easing === 'function') {
            return easing(progress);
          }
    
          return progress;
        },
    
        stop() {
          if (a.frameId) {
            window.cancelAnimationFrame(a.frameId);
          }
    
          a.animating = false;
          a.elements.each(el => {
            const element = el;
            delete element.dom7AnimateInstance;
          });
          a.que = [];
        },
    
        done(complete) {
          a.animating = false;
          a.elements.each(el => {
            const element = el;
            delete element.dom7AnimateInstance;
          });
          if (complete) complete(els);
    
          if (a.que.length > 0) {
            const que = a.que.shift();
            a.animate(que[0], que[1]);
          }
        },
    
        animate(props, params) {
          if (a.animating) {
            a.que.push([props, params]);
            return a;
          }
    
          const elements = []; // Define & Cache Initials & Units
    
          a.elements.each((el, index) => {
            let initialFullValue;
            let initialValue;
            let unit;
            let finalValue;
            let finalFullValue;
            if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
            elements[index] = {
              container: el
            };
            Object.keys(props).forEach(prop => {
              initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
              initialValue = parseFloat(initialFullValue);
              unit = initialFullValue.replace(initialValue, '');
              finalValue = parseFloat(props[prop]);
              finalFullValue = props[prop] + unit;
              elements[index][prop] = {
                initialFullValue,
                initialValue,
                unit,
                finalValue,
                finalFullValue,
                currentValue: initialValue
              };
            });
          });
          let startTime = null;
          let time;
          let elementsDone = 0;
          let propsDone = 0;
          let done;
          let began = false;
          a.animating = true;
    
          function render() {
            time = new Date().getTime();
            let progress;
            let easeProgress; // let el;
    
            if (!began) {
              began = true;
              if (params.begin) params.begin(els);
            }
    
            if (startTime === null) {
              startTime = time;
            }
    
            if (params.progress) {
              // eslint-disable-next-line
              params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
            }
    
            elements.forEach(element => {
              const el = element;
              if (done || el.done) return;
              Object.keys(props).forEach(prop => {
                if (done || el.done) return;
                progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
                easeProgress = a.easingProgress(params.easing, progress);
                const {
                  initialValue,
                  finalValue,
                  unit
                } = el[prop];
                el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
                const currentValue = el[prop].currentValue;
    
                if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
                  el.container.style[prop] = finalValue + unit;
                  propsDone += 1;
    
                  if (propsDone === Object.keys(props).length) {
                    el.done = true;
                    elementsDone += 1;
                  }
    
                  if (elementsDone === elements.length) {
                    done = true;
                  }
                }
    
                if (done) {
                  a.done(params.complete);
                  return;
                }
    
                el.container.style[prop] = currentValue + unit;
              });
            });
            if (done) return; // Then call
    
            a.frameId = window.requestAnimationFrame(render);
          }
    
          a.frameId = window.requestAnimationFrame(render);
          return a;
        }
    
      };
    
      if (a.elements.length === 0) {
        return els;
      }
    
      let animateInstance;
    
      for (let i = 0; i < a.elements.length; i += 1) {
        if (a.elements[i].dom7AnimateInstance) {
          animateInstance = a.elements[i].dom7AnimateInstance;
        } else a.elements[i].dom7AnimateInstance = a;
      }
    
      if (!animateInstance) {
        animateInstance = a;
      }
    
      if (initialProps === 'stop') {
        animateInstance.stop();
      } else {
        animateInstance.animate(a.props, a.params);
      }
    
      return els;
    }
    
    function stop() {
      const els = this;
    
      for (let i = 0; i < els.length; i += 1) {
        if (els[i].dom7AnimateInstance) {
          els[i].dom7AnimateInstance.stop();
        }
      }
    }
    
    const noTrigger = 'resize scroll'.split(' ');
    
    function shortcut(name) {
      function eventHandler(...args) {
        if (typeof args[0] === 'undefined') {
          for (let i = 0; i < this.length; i += 1) {
            if (noTrigger.indexOf(name) < 0) {
              if (name in this[i]) this[i][name]();else {
                $(this[i]).trigger(name);
              }
            }
          }
    
          return this;
        }
    
        return this.on(name, ...args);
      }
    
      return eventHandler;
    }
    
    const click = shortcut('click');
    const blur = shortcut('blur');
    const focus = shortcut('focus');
    const focusin = shortcut('focusin');
    const focusout = shortcut('focusout');
    const keyup = shortcut('keyup');
    const keydown = shortcut('keydown');
    const keypress = shortcut('keypress');
    const submit = shortcut('submit');
    const change = shortcut('change');
    const mousedown = shortcut('mousedown');
    const mousemove = shortcut('mousemove');
    const mouseup = shortcut('mouseup');
    const mouseenter = shortcut('mouseenter');
    const mouseleave = shortcut('mouseleave');
    const mouseout = shortcut('mouseout');
    const mouseover = shortcut('mouseover');
    const touchstart = shortcut('touchstart');
    const touchend = shortcut('touchend');
    const touchmove = shortcut('touchmove');
    const resize = shortcut('resize');
    const scroll = shortcut('scroll');
    
    export default $;
    export { $, add, addClass, animate, animationEnd, append, appendTo, attr, blur, change, children, click, closest, css, data, dataset, detach, each, empty, eq, filter, find, focus, focusin, focusout, hasClass, height, hide, html, index, insertAfter, insertBefore, is, keydown, keypress, keyup, mousedown, mouseenter, mouseleave, mousemove, mouseout, mouseover, mouseup, next, nextAll, off, offset, on, once, outerHeight, outerWidth, parent, parents, prepend, prependTo, prev, prevAll, prop, remove, removeAttr, removeClass, removeData, resize, scroll, scrollLeft, scrollTo, scrollTop, show, siblings, stop, styles, submit, text, toggleClass, touchend, touchmove, touchstart, transform, transition, transitionEnd, trigger, val, value, width };
    ",
    "import {
      $,
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition,
      on,
      off,
      trigger,
      transitionEnd,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove,
    } from 'dom7';
    
    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition,
      on,
      off,
      trigger,
      transitionEnd,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove,
    };
    
    Object.keys(Methods).forEach((methodName) => {
      Object.defineProperty($.fn, methodName, { value: Methods[methodName], writable: true });
    });
    
    export default $;
    ",
    "import { getWindow } from 'ssr-window';
    
    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach((key) => {
        try {
          object[key] = null;
        } catch (e) {
          // no getter for object
        }
        try {
          delete object[key];
        } catch (e) {
          // something got wrong
        }
      });
    }
    function nextTick(callback, delay = 0) {
      return setTimeout(callback, delay);
    }
    function now() {
      return Date.now();
    }
    function getComputedStyle(el) {
      const window = getWindow();
      let style;
      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }
      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }
      if (!style) {
        style = el.style;
      }
    
      return style;
    }
    function getTranslate(el, axis = 'x') {
      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
    
      const curStyle = getComputedStyle(el, null);
    
      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(',').length > 6) {
          curTransform = curTransform
            .split(', ')
            .map((a) => a.replace(',', '.'))
            .join(', ');
        }
        // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case
        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix =
          curStyle.MozTransform ||
          curStyle.OTransform ||
          curStyle.MsTransform ||
          curStyle.msTransform ||
          curStyle.transform ||
          curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }
    
      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }
      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }
      return curTransform || 0;
    }
    function isObject(o) {
      return (
        typeof o === 'object' &&
        o !== null &&
        o.constructor &&
        Object.prototype.toString.call(o).slice(8, -1) === 'Object'
      );
    }
    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }
      return node && (node.nodeType === 1 || node.nodeType === 11);
    }
    function extend(...args) {
      const to = Object(args[0]);
      const noExtend = ['__proto__', 'constructor', 'prototype'];
      for (let i = 1; i < args.length; i += 1) {
        const nextSource = args[i];
        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to;
    }
    
    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }
    
    function animateCSSModeScroll({ swiper, targetPosition, side }) {
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
    
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
    
      const dir = targetPosition > startPosition ? 'next' : 'prev';
    
      const isOutOfBound = (current, target) => {
        return (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);
      };
    
      const animate = () => {
        time = new Date().getTime();
        if (startTime === null) {
          startTime = time;
        }
    
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    
        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition,
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition,
            });
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }
        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };
      animate();
    }
    
    export {
      animateCSSModeScroll,
      deleteProps,
      nextTick,
      now,
      getTranslate,
      isObject,
      extend,
      getComputedStyle,
      setCSSProperty,
    };
    ",
    "import { getWindow, getDocument } from 'ssr-window';
    
    let support;
    
    function calcSupport() {
      const window = getWindow();
      const document = getDocument();
    
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
    
        touch: !!(
          'ontouchstart' in window ||
          (window.DocumentTouch && document instanceof window.DocumentTouch)
        ),
    
        passiveListener: (function checkPassiveListener() {
          let supportsPassive = false;
          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              },
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {
            // No support
          }
          return supportsPassive;
        })(),
    
        gestures: (function checkGestures() {
          return 'ongesturestart' in window;
        })(),
      };
    }
    
    function getSupport() {
      if (!support) {
        support = calcSupport();
      }
      return support;
    }
    
    export { getSupport };
    ",
    "import { getWindow } from 'ssr-window';
    import { getSupport } from './get-support.js';
    
    let deviceCached;
    
    function calcDevice({ userAgent } = {}) {
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
    
      const device = {
        ios: false,
        android: false,
      };
    
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
    
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === 'Win32';
      let macos = platform === 'MacIntel';
    
      // iPadOs 13 fix
      const iPadScreens = [
        '1024x1366',
        '1366x1024',
        '834x1194',
        '1194x834',
        '834x1112',
        '1112x834',
        '768x1024',
        '1024x768',
        '820x1180',
        '1180x820',
        '810x1080',
        '1080x810',
      ];
      if (
        !ipad &&
        macos &&
        support.touch &&
        iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0
      ) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      }
    
      // Android
      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }
      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      }
    
      // Export object
      return device;
    }
    
    function getDevice(overrides = {}) {
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }
      return deviceCached;
    }
    
    export { getDevice };
    ",
    "import { getWindow } from 'ssr-window';
    
    let browser;
    
    function calcBrowser() {
      const window = getWindow();
      function isSafari() {
        const ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }
      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
      };
    }
    
    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }
      return browser;
    }
    
    export { getBrowser };
    ",
    "/* eslint-disable no-underscore-dangle */
    
    export default {
      on(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach((event) => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
    
      once(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        function onceHandler(...args) {
          self.off(events, onceHandler);
          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }
          handler.apply(self, args);
        }
        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
    
      onAny(handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }
        return self;
      },
    
      offAny(handler) {
        const self = this;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);
        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }
        return self;
      },
    
      off(events, handler) {
        const self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach((event) => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (
                eventHandler === handler ||
                (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)
              ) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
    
      emit(...args) {
        const self = this;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }
        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
    
        eventsArray.forEach((event) => {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach((eventHandler) => {
              eventHandler.apply(context, [event, ...data]);
            });
          }
          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler) => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      },
    };
    ",
    "import updateSize from './updateSize.js';
    import updateSlides from './updateSlides.js';
    import updateAutoHeight from './updateAutoHeight.js';
    import updateSlidesOffset from './updateSlidesOffset.js';
    import updateSlidesProgress from './updateSlidesProgress.js';
    import updateProgress from './updateProgress.js';
    import updateSlidesClasses from './updateSlidesClasses.js';
    import updateActiveIndex from './updateActiveIndex.js';
    import updateClickedSlide from './updateClickedSlide.js';
    
    export default {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide,
    };
    ",
    "export default function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;
      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }
      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }
      if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
        return;
      }
    
      // Subtract paddings
      width =
        width -
        parseInt($el.css('padding-left') || 0, 10) -
        parseInt($el.css('padding-right') || 0, 10);
      height =
        height -
        parseInt($el.css('padding-top') || 0, 10) -
        parseInt($el.css('padding-bottom') || 0, 10);
    
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
    
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height,
      });
    }
    ",
    "import { setCSSProperty } from '../../shared/utils.js';
    
    export default function updateSlides() {
      const swiper = this;
      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        }
        // prettier-ignore
        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom',
        }[property];
      }
      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }
    
      const params = swiper.params;
    
      const { $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
    
      let offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }
    
      let offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }
    
      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
    
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;
      if (typeof swiperSize === 'undefined') {
        return;
      }
      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
      }
    
      swiper.virtualSize = -spaceBetween;
    
      // reset margins
      if (rtl) slides.css({ marginLeft: '', marginBottom: '', marginTop: '' });
      else slides.css({ marginRight: '', marginBottom: '', marginTop: '' });
    
      // reset cssMode offsets
      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }
    
      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      }
    
      // Calc slides
      let slideSize;
    
      const shouldResetSlideSize =
        params.slidesPerView === 'auto' &&
        params.breakpoints &&
        Object.keys(params.breakpoints).filter((key) => {
          return typeof params.breakpoints[key].slidesPerView !== 'undefined';
        }).length > 0;
    
      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);
        if (gridEnabled) {
          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
        }
        if (slide.css('display') === 'none') continue; // eslint-disable-line
    
        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = ``;
          }
          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;
          if (currentTransform) {
            slide[0].style.transform = 'none';
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }
          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            const width = getDirectionPropertyValue(slideStyles, 'width');
            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            const boxSizing = slideStyles.getPropertyValue('box-sizing');
            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              const { clientWidth, offsetWidth } = slide[0];
              slideSize =
                width +
                paddingLeft +
                paddingRight +
                marginLeft +
                marginRight +
                (offsetWidth - clientWidth);
            }
          }
          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }
          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);
    
          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
          }
        }
        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
    
        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0)
            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (
            (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %
              swiper.params.slidesPerGroup ===
            0
          )
            snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }
    
        swiper.virtualSize += slideSize + spaceBetween;
    
        prevSlideSize = slideSize;
    
        index += 1;
      }
      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    
      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
      }
      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`,
        });
      }
    
      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      }
    
      // Remove last grid elements depending on width
      if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }
        snapGrid = newSlidesGrid;
    
        if (
          Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) >
          1
        ) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }
      if (snapGrid.length === 0) snapGrid = [0];
    
      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides
          .filter((_, slideIndex) => {
            if (!params.cssMode) return true;
            if (slideIndex === slides.length - 1) {
              return false;
            }
            return true;
          })
          .css({ [key]: `${spaceBetween}px` });
      }
    
      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map((snap) => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }
    
      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }
    
      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid,
      });
    
      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        setCSSProperty(
          swiper.wrapperEl,
          '--swiper-centered-offset-after',
          `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`,
        );
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
      }
    
      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }
      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }
    
      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }
    
      if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
          if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
          swiper.$el.removeClass(backFaceHiddenClass);
        }
      }
    }
    ",
    "export default function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;
      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }
    
      const getSlideByIndex = (index) => {
        if (isVirtual) {
          return swiper.slides.filter(
            (el) => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index,
          )[0];
        }
        return swiper.slides.eq(index)[0];
      };
      // Find slides currently in view
      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each((slide) => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      }
    
      // Find new height from highest slide in view
      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      }
    
      // Update Height
      if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }
    ",
    "export default function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;
      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal()
          ? slides[i].offsetLeft
          : slides[i].offsetTop;
      }
    }
    ",
    "import $ from '../../shared/dom.js';
    
    export default function updateSlidesProgress(translate = (this && this.translate) || 0) {
      const swiper = this;
      const params = swiper.params;
    
      const { slides, rtlTranslate: rtl, snapGrid } = swiper;
    
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
    
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate;
    
      // Visible Slides
      slides.removeClass(params.slideVisibleClass);
    
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];
    
      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }
    
        const slideProgress =
          (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /
          (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress =
          (offsetCenter -
            snapGrid[0] +
            (params.centeredSlides ? swiper.minTranslate() : 0) -
            slideOffset) /
          (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible =
          (slideBefore >= 0 && slideBefore < swiper.size - 1) ||
          (slideAfter > 1 && slideAfter <= swiper.size) ||
          (slideBefore <= 0 && slideAfter >= swiper.size);
        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }
      swiper.visibleSlides = $(swiper.visibleSlides);
    }
    ",
    "export default function updateProgress(translate) {
      const swiper = this;
      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        // eslint-disable-next-line
        translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;
      }
      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let { progress, isBeginning, isEnd } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;
      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }
      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd,
      });
    
      if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight))
        swiper.updateSlidesProgress(translate);
    
      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }
      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }
      if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
        swiper.emit('fromEdge');
      }
    
      swiper.emit('progress', progress);
    }
    ",
    "export default function updateSlidesClasses() {
      const swiper = this;
    
      const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
    
      slides.removeClass(
        `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`,
      );
    
      let activeSlide;
      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(
          `.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`,
        );
      } else {
        activeSlide = slides.eq(activeIndex);
      }
    
      // Active classes
      activeSlide.addClass(params.slideActiveClass);
    
      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children(
              `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`,
            )
            .addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl
            .children(
              `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`,
            )
            .addClass(params.slideDuplicateActiveClass);
        }
      }
      // Next Slide
      let nextSlide = activeSlide
        .nextAll(`.${params.slideClass}`)
        .eq(0)
        .addClass(params.slideNextClass);
      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      }
      // Prev Slide
      let prevSlide = activeSlide
        .prevAll(`.${params.slideClass}`)
        .eq(0)
        .addClass(params.slidePrevClass);
      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }
      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children(
              `.${params.slideClass}:not(.${
                params.slideDuplicateClass
              })[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`,
            )
            .addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl
            .children(
              `.${params.slideClass}.${
                params.slideDuplicateClass
              }[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`,
            )
            .addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children(
              `.${params.slideClass}:not(.${
                params.slideDuplicateClass
              })[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`,
            )
            .addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl
            .children(
              `.${params.slideClass}.${
                params.slideDuplicateClass
              }[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`,
            )
            .addClass(params.slideDuplicatePrevClass);
        }
      }
      swiper.emitSlidesClasses();
    }
    ",
    "export default function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex,
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;
      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (
              translate >= slidesGrid[i] &&
              translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2
            ) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        }
        // Normalize slideIndex
        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }
      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }
        return;
      }
    
      // Get real index
      const realIndex = parseInt(
        swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex,
        10,
      );
    
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex,
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');
      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }
      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }
    ",
    "import $ from '../../shared/dom.js';
    
    export default function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;
    
      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }
    
      if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }
      if (
        params.slideToClickedSlide &&
        swiper.clickedIndex !== undefined &&
        swiper.clickedIndex !== swiper.activeIndex
      ) {
        swiper.slideToClickedSlide();
      }
    }
    ",
    "import getTranslate from './getTranslate.js';
    import setTranslate from './setTranslate.js';
    import minTranslate from './minTranslate.js';
    import maxTranslate from './maxTranslate.js';
    import translateTo from './translateTo.js';
    
    export default {
      getTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo,
    };
    ",
    "import { getTranslate } from '../../shared/utils.js';
    
    export default function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
      const swiper = this;
    
      const { params, rtlTranslate: rtl, translate, $wrapperEl } = swiper;
    
      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }
      if (params.cssMode) {
        return translate;
      }
    
      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
    
      return currentTranslate || 0;
    }
    ",
    "export default function setTranslate(translate, byController) {
      const swiper = this;
      const { rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;
    
      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }
    
      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }
    
      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }
      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y;
    
      // Check if we need to update progress
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }
    
      swiper.emit('setTranslate', swiper.translate, byController);
    }
    ",
    "export default function minTranslate() {
      return -this.snapGrid[0];
    }
    ",
    "export default function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }
    ",
    "import { animateCSSModeScroll } from '../../shared/utils.js';
    
    export default function translateTo(
      translate = 0,
      speed = this.params.speed,
      runCallbacks = true,
      translateBounds = true,
      internal,
    ) {
      const swiper = this;
    
      const { params, wrapperEl } = swiper;
    
      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }
    
      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
      else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
      else newTranslate = translate;
    
      // Update progress
      swiper.updateProgress(newTranslate);
    
      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({ swiper, targetPosition: -newTranslate, side: isH ? 'left' : 'top' });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth',
          });
        }
        return true;
      }
    
      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }
        if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener(
                'transitionend',
                swiper.onTranslateToWrapperTransitionEnd,
              );
              swiper.$wrapperEl[0].removeEventListener(
                'webkitTransitionEnd',
                swiper.onTranslateToWrapperTransitionEnd,
              );
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;
              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }
          swiper.$wrapperEl[0].addEventListener(
            'transitionend',
            swiper.onTranslateToWrapperTransitionEnd,
          );
          swiper.$wrapperEl[0].addEventListener(
            'webkitTransitionEnd',
            swiper.onTranslateToWrapperTransitionEnd,
          );
        }
      }
    
      return true;
    }
    ",
    "export default function transitionEmit({ swiper, runCallbacks, direction, step }) {
      const { activeIndex, previousIndex } = swiper;
      let dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
      }
    
      swiper.emit(`transition${step}`);
    
      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }
        swiper.emit(`slideChangeTransition${step}`);
        if (dir === 'next') {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }
    ",
    "import slideTo from './slideTo.js';
    import slideToLoop from './slideToLoop.js';
    import slideNext from './slideNext.js';
    import slidePrev from './slidePrev.js';
    import slideReset from './slideReset.js';
    import slideToClosest from './slideToClosest.js';
    import slideToClickedSlide from './slideToClickedSlide.js';
    
    export default {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide,
    };
    ",
    "import { animateCSSModeScroll } from '../../shared/utils.js';
    
    export default function slideTo(
      index = 0,
      speed = this.params.speed,
      runCallbacks = true,
      internal,
      initial,
    ) {
      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error(
          `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`,
        );
      }
    
      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
    
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */
        const isValidNumber = isFinite(indexAsNumber);
    
        if (!isValidNumber) {
          throw new Error(
            `The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`,
          );
        }
    
        // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.
        index = indexAsNumber;
      }
    
      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
    
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled,
      } = swiper;
    
      if (
        (swiper.animating && params.preventInteractionOnTransition) ||
        (!enabled && !internal && !initial)
      ) {
        return false;
      }
    
      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    
      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }
    
      const translate = -snapGrid[snapIndex];
    
      // Update progress
      swiper.updateProgress(translate);
    
      // Normalize slideIndex
      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          const normalizedTranslate = -Math.floor(translate * 100);
          const normalizedGrid = Math.floor(slidesGrid[i] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (
              normalizedTranslate >= normalizedGrid &&
              normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2
            ) {
              slideIndex = i;
            } else if (
              normalizedTranslate >= normalizedGrid &&
              normalizedTranslate < normalizedGridNext
            ) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      }
      // Directions locks
      if (swiper.initialized && slideIndex !== activeIndex) {
        if (
          !swiper.allowSlideNext &&
          translate < swiper.translate &&
          translate < swiper.minTranslate()
        ) {
          return false;
        }
        if (
          !swiper.allowSlidePrev &&
          translate > swiper.translate &&
          translate > swiper.maxTranslate()
        ) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }
    
      let direction;
      if (slideIndex > activeIndex) direction = 'next';
      else if (slideIndex < activeIndex) direction = 'prev';
      else direction = 'reset';
    
      // Update Index
      if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
        swiper.updateActiveIndex(slideIndex);
        // Update Height
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }
        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
      }
      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;
        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({ swiper, targetPosition: t, side: isH ? 'left' : 'top' });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth',
          });
        }
        return true;
      }
    
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
    
      if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
      } else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener(
              'transitionend',
              swiper.onSlideToWrapperTransitionEnd,
            );
            swiper.$wrapperEl[0].removeEventListener(
              'webkitTransitionEnd',
              swiper.onSlideToWrapperTransitionEnd,
            );
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener(
          'webkitTransitionEnd',
          swiper.onSlideToWrapperTransitionEnd,
        );
      }
    
      return true;
    }
    ",
    "export default function slideToLoop(
      index = 0,
      speed = this.params.speed,
      runCallbacks = true,
      internal,
    ) {
      const swiper = this;
      let newIndex = index;
      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }
    
      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }
    ",
    "/* eslint no-unused-vars: "off" */
    export default function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const { animating, enabled, params } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;
      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }
      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
      }
      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }
    ",
    "/* eslint no-unused-vars: "off" */
    export default function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const { params, animating, snapGrid, slidesGrid, rtlTranslate, enabled } = swiper;
      if (!enabled) return swiper;
    
      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      const translate = rtlTranslate ? swiper.translate : -swiper.translate;
    
      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }
      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
    
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === 'undefined' && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });
        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }
      let prevIndex = 0;
      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        if (
          params.slidesPerView === 'auto' &&
          params.slidesPerGroup === 1 &&
          params.slidesPerGroupAuto
        ) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }
      if (params.rewind && swiper.isBeginning) {
        const lastIndex =
          swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual
            ? swiper.virtual.slides.length - 1
            : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
      }
      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    ",
    "/* eslint no-unused-vars: "off" */
    export default function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }
    ",
    "/* eslint no-unused-vars: "off" */
    export default function slideToClosest(
      speed = this.params.speed,
      runCallbacks = true,
      internal,
      threshold = 0.5,
    ) {
      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    
      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }
      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
    
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }
    ",
    "import $ from '../../shared/dom.js';
    import { nextTick } from '../../shared/utils.js';
    
    export default function slideToClickedSlide() {
      const swiper = this;
      const { params, $wrapperEl } = swiper;
    
      const slidesPerView =
        params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;
      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        if (params.centeredSlides) {
          if (
            slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||
            slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2
          ) {
            swiper.loopFix();
            slideToIndex = $wrapperEl
              .children(
                `.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`,
              )
              .eq(0)
              .index();
    
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl
            .children(
              `.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`,
            )
            .eq(0)
            .index();
    
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }
    ",
    "import loopCreate from './loopCreate.js';
    import loopFix from './loopFix.js';
    import loopDestroy from './loopDestroy.js';
    
    export default {
      loopCreate,
      loopFix,
      loopDestroy,
    };
    ",
    "import { getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    
    export default function loopCreate() {
      const swiper = this;
      const document = getDocument();
      const { params, $wrapperEl } = swiper;
      // Remove duplicated slides
      const $selector =
        $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
    
      let slides = $selector.children(`.${params.slideClass}`);
    
      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(document.createElement('div')).addClass(
              `${params.slideClass} ${params.slideBlankClass}`,
            );
            $selector.append(blankNode);
          }
          slides = $selector.children(`.${params.slideClass}`);
        }
      }
    
      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
    
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;
      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }
    
      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index) => {
        const slide = $(el);
        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }
        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }
        slide.attr('data-swiper-slide-index', index);
      });
      for (let i = 0; i < appendSlides.length; i += 1) {
        $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }
    ",
    "export default function loopFix() {
      const swiper = this;
    
      swiper.emit('beforeLoopFix');
    
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl,
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
    
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate();
    
      // Fix For Negative Oversliding
      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
    
      swiper.emit('loopFix');
    }
    ",
    "export default function loopDestroy() {
      const swiper = this;
      const { $wrapperEl, params, slides } = swiper;
      $wrapperEl
        .children(
          `.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`,
        )
        .remove();
      slides.removeAttr('data-swiper-slide-index');
    }
    ",
    "import { getWindow, getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    import { now } from '../../shared/utils.js';
    
    // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
    function closestElement(selector, base = this) {
      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }
      return __closestFrom(base);
    }
    
    export default function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      const window = getWindow();
    
      const data = swiper.touchEventsData;
      const { params, touches, enabled } = swiper;
      if (!enabled) return;
    
      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }
      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let $targetEl = $(e.target);
    
      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }
      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return;
    
      // change target el for shadow root component
      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }
    
      const noSwipingSelector = params.noSwipingSelector
        ? params.noSwipingSelector
        : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot);
    
      // use closestElement for shadow root element to get the actual closest for nested shadow root element
      if (
        params.noSwiping &&
        (isTargetShadow
          ? closestElement(noSwipingSelector, e.target)
          : $targetEl.closest(noSwipingSelector)[0])
      ) {
        swiper.allowClick = true;
        return;
      }
    
      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }
    
      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY;
    
      // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore
    
      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
      if (
        edgeSwipeDetection &&
        (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)
      ) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }
    
      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined,
      });
    
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;
      if (e.type !== 'touchstart') {
        let preventDefault = true;
        if ($targetEl.is(data.focusableElements)) {
          preventDefault = false;
          if ($targetEl[0].nodeName === 'SELECT') {
            data.isTouched = false;
          }
        }
        if (
          document.activeElement &&
          $(document.activeElement).is(data.focusableElements) &&
          document.activeElement !== $targetEl[0]
        ) {
          document.activeElement.blur();
        }
    
        const shouldPreventDefault =
          preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if (
          (params.touchStartForcePreventDefault || shouldPreventDefault) &&
          !$targetEl[0].isContentEditable
        ) {
          e.preventDefault();
        }
      }
      if (
        swiper.params.freeMode &&
        swiper.params.freeMode.enabled &&
        swiper.freeMode &&
        swiper.animating &&
        !params.cssMode
      ) {
        swiper.freeMode.onTouchStart();
      }
      swiper.emit('touchStart', e);
    }
    ",
    "import { getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    import { now } from '../../shared/utils.js';
    
    export default function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const { params, touches, rtlTranslate: rtl, enabled } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }
        return;
      }
      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch =
        e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }
      if (!swiper.allowTouchMove) {
        if (!$(e.target).is(data.focusableElements)) {
          swiper.allowClick = false;
        }
        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
          });
          data.touchStartTime = now();
        }
        return;
      }
      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (
            (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||
            (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
          ) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (
          (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||
          (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
        ) {
          return;
        }
      }
      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }
      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }
      if (e.targetTouches && e.targetTouches.length > 1) return;
    
      touches.currentX = pageX;
      touches.currentY = pageY;
    
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
        return;
    
      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;
        if (
          (swiper.isHorizontal() && touches.currentY === touches.startY) ||
          (swiper.isVertical() && touches.currentX === touches.startX)
        ) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
            data.isScrolling = swiper.isHorizontal()
              ? touchAngle > params.touchAngle
              : 90 - touchAngle > params.touchAngle;
          }
        }
      }
      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }
      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }
      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }
      if (!data.startMoving) {
        return;
      }
      swiper.allowClick = false;
      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }
      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }
    
      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }
        data.allowMomentumBounce = false;
        // Grab Cursor
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }
        swiper.emit('sliderFirstMove', e);
      }
      swiper.emit('sliderMove', e);
      data.isMoved = true;
    
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
    
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
    
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
    
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }
      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance)
          data.currentTranslate =
            swiper.minTranslate() -
            1 +
            (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance)
          data.currentTranslate =
            swiper.maxTranslate() +
            1 -
            (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    
      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      }
    
      // Directions locks
      if (
        !swiper.allowSlideNext &&
        swiper.swipeDirection === 'next' &&
        data.currentTranslate < data.startTranslate
      ) {
        data.currentTranslate = data.startTranslate;
      }
      if (
        !swiper.allowSlidePrev &&
        swiper.swipeDirection === 'prev' &&
        data.currentTranslate > data.startTranslate
      ) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      }
    
      // Threshold
      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal()
              ? touches.currentX - touches.startX
              : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }
    
      if (!params.followFinger || params.cssMode) return;
    
      // Update active index in free mode
      if (
        (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||
        params.watchSlidesProgress
      ) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      }
      // Update progress
      swiper.updateProgress(data.currentTranslate);
      // Update translate
      swiper.setTranslate(data.currentTranslate);
    }
    ",
    "import { now, nextTick } from '../../shared/utils.js';
    
    export default function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
    
      const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      // Return Grab Cursor
      if (
        params.grabCursor &&
        data.isMoved &&
        data.isTouched &&
        (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
      ) {
        swiper.setGrabCursor(false);
      }
    
      // Time diff
      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;
    
      // Tap, doubleTap, Click
      if (swiper.allowClick) {
        const pathTree = e.path || (e.composedPath && e.composedPath());
        swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);
        swiper.emit('tap click', e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }
    
      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });
    
      if (
        !data.isTouched ||
        !data.isMoved ||
        !swiper.swipeDirection ||
        touches.diff === 0 ||
        data.currentTranslate === data.startTranslate
      ) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
    
      let currentPos;
      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }
    
      if (params.cssMode) {
        return;
      }
    
      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({ currentPos });
        return;
      }
    
      // Find current slide
      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];
      for (
        let i = 0;
        i < slidesGrid.length;
        i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup
      ) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }
    
      let rewindFirstIndex = null;
      let rewindLastIndex = null;
      if (params.rewind) {
        if (swiper.isBeginning) {
          rewindLastIndex =
            swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual
              ? swiper.virtual.slides.length - 1
              : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
          rewindFirstIndex = 0;
        }
      }
      // Find current slide size
      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio)
            swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
          else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) {
            swiper.slideTo(stopIndex + increment);
          } else if (
            rewindLastIndex !== null &&
            ratio < 0 &&
            Math.abs(ratio) > params.longSwipesRatio
          ) {
            swiper.slideTo(rewindLastIndex);
          } else {
            swiper.slideTo(stopIndex);
          }
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        const isNavButtonTarget =
          swiper.navigation &&
          (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
          }
          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }
    ",
    "export default function onResize() {
      const swiper = this;
    
      const { params, el } = swiper;
    
      if (el && el.offsetWidth === 0) return;
    
      // Breakpoints
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
    
      // Save locks
      const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
    
      // Disable locks on resize
      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
    
      swiper.updateSize();
      swiper.updateSlides();
    
      swiper.updateSlidesClasses();
      if (
        (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&
        swiper.isEnd &&
        !swiper.isBeginning &&
        !swiper.params.centeredSlides
      ) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
    
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      }
      // Return locks after resize
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
    
      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }
    ",
    "export default function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;
      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }
    ",
    "export default function onScroll() {
      const swiper = this;
      const { wrapperEl, rtlTranslate, enabled } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;
      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      }
      // eslint-disable-next-line
      if (swiper.translate === 0) swiper.translate = 0;
    
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }
    
      swiper.emit('setTranslate', swiper.translate, false);
    }
    ",
    "import { getDocument } from 'ssr-window';
    
    import onTouchStart from './onTouchStart.js';
    import onTouchMove from './onTouchMove.js';
    import onTouchEnd from './onTouchEnd.js';
    import onResize from './onResize.js';
    import onClick from './onClick.js';
    import onScroll from './onScroll.js';
    
    let dummyEventAttached = false;
    function dummyEventListener() {}
    
    const events = (swiper, method) => {
      const document = getDocument();
      const { params, touchEvents, el, wrapperEl, device, support } = swiper;
      const capture = !!params.nested;
      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      const swiperMethod = method;
    
      // Touch Events
      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener =
          touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners
            ? { passive: true, capture: false }
            : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](
          touchEvents.move,
          swiper.onTouchMove,
          support.passiveListener ? { passive: false, capture } : capture,
        );
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      }
      // Prevent Links Clicks
      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }
      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      }
    
      // Resize handler
      if (params.updateOnWindowResize) {
        swiper[swiperMethod](
          device.ios || device.android
            ? 'resize orientationchange observerUpdate'
            : 'resize observerUpdate',
          onResize,
          true,
        );
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };
    
    function attachEvents() {
      const swiper = this;
      const document = getDocument();
      const { params, support } = swiper;
    
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
    
      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }
    
      swiper.onClick = onClick.bind(swiper);
    
      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    
      events(swiper, 'on');
    }
    
    function detachEvents() {
      const swiper = this;
      events(swiper, 'off');
    }
    
    export default {
      attachEvents,
      detachEvents,
    };
    ",
    "import { extend } from '../../shared/utils.js';
    
    const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };
    
    export default function setBreakpoint() {
      const swiper = this;
      const { activeIndex, initialized, loopedSlides = 0, params, $el } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;
    
      // Get breakpoint for window width and update parameters
      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
    
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
    
      const wasEnabled = params.enabled;
    
      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(
          `${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`,
        );
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);
        if (
          (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||
          (!breakpointParams.grid.fill && params.grid.fill === 'column')
        ) {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }
        swiper.emitContainerClasses();
      }
    
      const directionChanged =
        breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop =
        params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    
      if (directionChanged && initialized) {
        swiper.changeDirection();
      }
      extend(swiper.params, breakpointParams);
    
      const isEnabled = swiper.params.enabled;
    
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
      });
    
      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }
    
      swiper.currentBreakpoint = breakpoint;
    
      swiper.emit('_beforeBreakpoint', breakpointParams);
    
      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }
    
      swiper.emit('breakpoint', breakpointParams);
    }
    ",
    "import addClasses from './addClasses.js';
    import removeClasses from './removeClasses.js';
    
    export default { addClasses, removeClasses };
    ",
    "function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach((item) => {
        if (typeof item === 'object') {
          Object.keys(item).forEach((classNames) => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }
    
    export default function addClasses() {
      const swiper = this;
      const { classNames, params, rtl, $el, device, support } = swiper;
      // prettier-ignore
      const suffixes = prepareClasses([
        'initialized',
        params.direction,
        { 'pointer-events': !support.touch },
        { 'free-mode': swiper.params.freeMode && params.freeMode.enabled },
        { 'autoheight': params.autoHeight },
        { 'rtl': rtl },
        { 'grid': params.grid && params.grid.rows > 1 },
        { 'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column' },
        { 'android': device.android },
        { 'ios': device.ios },
        { 'css-mode': params.cssMode },
        { 'centered': params.cssMode && params.centeredSlides },
      ], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(' '));
      swiper.emitContainerClasses();
    }
    ",
    "export default function removeClasses() {
      const swiper = this;
      const { $el, classNames } = swiper;
    
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }
    ",
    "function checkOverflow() {
      const swiper = this;
      const { isLocked: wasLocked, params } = swiper;
      const { slidesOffsetBefore } = params;
    
      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge =
          swiper.slidesGrid[lastSlideIndex] +
          swiper.slidesSizesGrid[lastSlideIndex] +
          slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }
      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }
      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }
    
      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }
      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }
    
    export default { checkOverflow };
    ",
    "export default {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
    
      // Overrides
      width: null,
      height: null,
    
      //
      preventInteractionOnTransition: false,
    
      // ssr
      userAgent: null,
      url: null,
    
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
    
      // Autoheight
      autoHeight: false,
    
      // Set wrapper width
      setWrapperSize: false,
    
      // Virtual Translate
      virtualTranslate: false,
    
      // Effects
      effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
    
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0, // in px
      slidesOffsetAfter: 0, // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
    
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
    
      // Round length
      roundLengths: false,
    
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
    
      // Unique Navigation Elements
      uniqueNavElements: true,
    
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
    
      // Progress
      watchSlidesProgress: false,
    
      // Cursor
      grabCursor: false,
    
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
    
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
    
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
    
      // rewind
      rewind: false,
    
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null, // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
    
      // Passive Listeners
      passiveListeners: true,
    
      maxBackfaceHiddenSlides: 10,
    
      // NS
      containerModifierClass: 'swiper-', // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
    
      // Callbacks
      runCallbacksOnInit: true,
    
      // Internals
      _emitClasses: false,
    };
    ",
    "import { extend } from '../shared/utils.js';
    
    export default function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj = {}) {
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) {
          extend(allModulesParams, obj);
          return;
        }
        if (
          ['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 &&
          params[moduleParamName] === true
        ) {
          params[moduleParamName] = { auto: true };
        }
        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend(allModulesParams, obj);
          return;
        }
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
        extend(allModulesParams, obj);
      };
    }
    ",
    "/* eslint no-param-reassign: "off" */
    import { getDocument } from 'ssr-window';
    import $ from '../shared/dom.js';
    import { extend, now, deleteProps } from '../shared/utils.js';
    import { getSupport } from '../shared/get-support.js';
    import { getDevice } from '../shared/get-device.js';
    import { getBrowser } from '../shared/get-browser.js';
    
    import Resize from './modules/resize/resize.js';
    import Observer from './modules/observer/observer.js';
    
    import eventsEmitter from './events-emitter.js';
    
    import update from './update/index.js';
    import translate from './translate/index.js';
    import transition from './transition/index.js';
    import slide from './slide/index.js';
    import loop from './loop/index.js';
    import grabCursor from './grab-cursor/index.js';
    import events from './events/index.js';
    import breakpoints from './breakpoints/index.js';
    import classes from './classes/index.js';
    import images from './images/index.js';
    import checkOverflow from './check-overflow/index.js';
    
    import defaults from './defaults.js';
    import moduleExtendParams from './moduleExtendParams.js';
    
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition,
      slide,
      loop,
      grabCursor,
      events,
      breakpoints,
      checkOverflow,
      classes,
      images,
    };
    
    const extendedDefaults = {};
    
    class Swiper {
      constructor(...args) {
        let el;
        let params;
        if (
          args.length === 1 &&
          args[0].constructor &&
          Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'
        ) {
          params = args[0];
        } else {
          [el, params] = args;
        }
        if (!params) params = {};
    
        params = extend({}, params);
        if (el && !params.el) params.el = el;
    
        if (params.el && $(params.el).length > 1) {
          const swipers = [];
          $(params.el).each((containerEl) => {
            const newParams = extend({}, params, { el: containerEl });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        }
    
        // Swiper Instance
        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({ userAgent: params.userAgent });
        swiper.browser = getBrowser();
    
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];
        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }
    
        const allModulesParams = {};
    
        swiper.modules.forEach((mod) => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper),
          });
        });
    
        // Extend defaults with modules params
        const swiperParams = extend({}, defaults, allModulesParams);
    
        // Extend defaults with passed params
        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params);
    
        // add event listeners
        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach((eventName) => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }
        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        }
    
        // Save Dom lib
        swiper.$ = $;
    
        // Extend Swiper
        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
    
          // Classes
          classNames: [],
    
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
    
          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical() {
            return swiper.params.direction === 'vertical';
          },
    
          // Indexes
          activeIndex: 0,
          realIndex: 0,
    
          //
          isBeginning: true,
          isEnd: false,
    
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
    
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
    
          // Touch Events
          touchEvents: (function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            const desktop = ['pointerdown', 'pointermove', 'pointerup'];
    
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3],
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2],
            };
            return swiper.support.touch || !swiper.params.simulateTouch
              ? swiper.touchEventsTouch
              : swiper.touchEventsDesktop;
          })(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined,
          },
    
          // Clicks
          allowClick: true,
    
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
    
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0,
          },
    
          // Images
          imagesToLoad: [],
          imagesLoaded: 0,
        });
    
        swiper.emit('_swiper');
    
        // Init
        if (swiper.params.init) {
          swiper.init();
        }
    
        // Return app instance
        return swiper;
      }
    
      enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }
        swiper.emit('enable');
      }
    
      disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }
        swiper.emit('disable');
      }
    
      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
    
      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter((className) => {
          return (
            className.indexOf('swiper') === 0 ||
            className.indexOf(swiper.params.containerModifierClass) === 0
          );
        });
        swiper.emit('_containerClasses', cls.join(' '));
      }
    
      getSlideClasses(slideEl) {
        const swiper = this;
    
        return slideEl.className
          .split(' ')
          .filter((className) => {
            return (
              className.indexOf('swiper-slide') === 0 ||
              className.indexOf(swiper.params.slideClass) === 0
            );
          })
          .join(' ');
      }
    
      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.each((slideEl) => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({ slideEl, classNames });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      }
    
      slidesPerViewDynamic(view = 'current', exact = false) {
        const swiper = this;
        const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;
        let spv = 1;
        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          // eslint-disable-next-line
          if (view === 'current') {
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              const slideInView = exact
                ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize
                : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            // previous
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          }
        }
        return spv;
      }
    
      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const { snapGrid, params } = swiper;
        // Breakpoints
        if (params.breakpoints) {
          swiper.setBreakpoint();
        }
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
    
        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(
            Math.max(translateValue, swiper.maxTranslate()),
            swiper.minTranslate(),
          );
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
        let translated;
        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate();
          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if (
            (swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) &&
            swiper.isEnd &&
            !swiper.params.centeredSlides
          ) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }
          if (!translated) {
            setTranslate();
          }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }
        swiper.emit('update');
      }
    
      changeDirection(newDirection, needUpdate = true) {
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }
        if (
          newDirection === currentDirection ||
          (newDirection !== 'horizontal' && newDirection !== 'vertical')
        ) {
          return swiper;
        }
    
        swiper.$el
          .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)
          .addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
    
        swiper.params.direction = newDirection;
    
        swiper.slides.each((slideEl) => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
    
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
    
        return swiper;
      }
    
      mount(el) {
        const swiper = this;
        if (swiper.mounted) return true;
    
        // Find el
        const $el = $(el || swiper.params.el);
        el = $el[0];
    
        if (!el) {
          return false;
        }
    
        el.swiper = swiper;
    
        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };
    
        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = $(el.shadowRoot.querySelector(getWrapperSelector()));
            // Children needs to return slot items
            res.children = (options) => $el.children(options);
            return res;
          }
          return $el.children(getWrapperSelector());
        };
        // Find Wrapper
        let $wrapperEl = getWrapper();
        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document = getDocument();
          const wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
            $wrapperEl.append(slideEl);
          });
        }
    
        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
    
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate:
            swiper.params.direction === 'horizontal' &&
            (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box',
        });
    
        return true;
      }
    
      init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
    
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
    
        swiper.emit('beforeInit');
    
        // Set breakpoint
        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        }
    
        // Add Classes
        swiper.addClasses();
    
        // Create loop
        if (swiper.params.loop) {
          swiper.loopCreate();
        }
    
        // Update size
        swiper.updateSize();
    
        // Update slides
        swiper.updateSlides();
    
        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        }
    
        // Set Grab Cursor
        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }
    
        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        }
    
        // Slide To Initial Slide
        if (swiper.params.loop) {
          swiper.slideTo(
            swiper.params.initialSlide + swiper.loopedSlides,
            0,
            swiper.params.runCallbacksOnInit,
            false,
            true,
          );
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
    
        // Attach events
        swiper.attachEvents();
    
        // Init Flag
        swiper.initialized = true;
    
        // Emit
        swiper.emit('init');
        swiper.emit('afterInit');
    
        return swiper;
      }
    
      destroy(deleteInstance = true, cleanStyles = true) {
        const swiper = this;
        const { params, $el, $wrapperEl, slides } = swiper;
    
        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }
    
        swiper.emit('beforeDestroy');
    
        // Init Flag
        swiper.initialized = false;
    
        // Detach events
        swiper.detachEvents();
    
        // Destroy loop
        if (params.loop) {
          swiper.loopDestroy();
        }
    
        // Cleanup styles
        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');
          if (slides && slides.length) {
            slides
              .removeClass(
                [
                  params.slideVisibleClass,
                  params.slideActiveClass,
                  params.slideNextClass,
                  params.slidePrevClass,
                ].join(' '),
              )
              .removeAttr('style')
              .removeAttr('data-swiper-slide-index');
          }
        }
    
        swiper.emit('destroy');
    
        // Detach emitter events
        Object.keys(swiper.eventsListeners).forEach((eventName) => {
          swiper.off(eventName);
        });
    
        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }
        swiper.destroyed = true;
    
        return null;
      }
    
      static extendDefaults(newDefaults) {
        extend(extendedDefaults, newDefaults);
      }
    
      static get extendedDefaults() {
        return extendedDefaults;
      }
    
      static get defaults() {
        return defaults;
      }
    
      static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;
    
        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }
    
      static use(module) {
        if (Array.isArray(module)) {
          module.forEach((m) => Swiper.installModule(m));
          return Swiper;
        }
        Swiper.installModule(module);
        return Swiper;
      }
    }
    
    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    
    Swiper.use([Resize, Observer]);
    
    export default Swiper;
    ",
    "import setTransition from './setTransition.js';
    import transitionStart from './transitionStart.js';
    import transitionEnd from './transitionEnd.js';
    
    export default {
      setTransition,
      transitionStart,
      transitionEnd,
    };
    ",
    "export default function setTransition(duration, byController) {
      const swiper = this;
    
      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }
    
      swiper.emit('setTransition', duration, byController);
    }
    ",
    "import transitionEmit from './transitionEmit.js';
    
    export default function transitionStart(runCallbacks = true, direction) {
      const swiper = this;
      const { params } = swiper;
      if (params.cssMode) return;
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    
      transitionEmit({ swiper, runCallbacks, direction, step: 'Start' });
    }
    ",
    "import transitionEmit from './transitionEmit.js';
    
    export default function transitionEnd(runCallbacks = true, direction) {
      const swiper = this;
      const { params } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
    
      transitionEmit({ swiper, runCallbacks, direction, step: 'End' });
    }
    ",
    "import setGrabCursor from './setGrabCursor.js';
    import unsetGrabCursor from './unsetGrabCursor.js';
    
    export default {
      setGrabCursor,
      unsetGrabCursor,
    };
    ",
    "export default function setGrabCursor(moving) {
      const swiper = this;
      if (
        swiper.support.touch ||
        !swiper.params.simulateTouch ||
        (swiper.params.watchOverflow && swiper.isLocked) ||
        swiper.params.cssMode
      )
        return;
      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }
    ",
    "export default function unsetGrabCursor() {
      const swiper = this;
      if (
        swiper.support.touch ||
        (swiper.params.watchOverflow && swiper.isLocked) ||
        swiper.params.cssMode
      ) {
        return;
      }
      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }
    ",
    "import setBreakpoint from './setBreakpoint.js';
    import getBreakpoint from './getBreakpoint.js';
    
    export default { setBreakpoint, getBreakpoint };
    ",
    "import { getWindow } from 'ssr-window';
    
    export default function getBreakpoint(breakpoints, base = 'window', containerEl) {
      if (!breakpoints || (base === 'container' && !containerEl)) return undefined;
      let breakpoint = false;
    
      const window = getWindow();
      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
    
      const points = Object.keys(breakpoints).map((point) => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return { value, point };
        }
        return { value: point, point };
      });
    
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
      for (let i = 0; i < points.length; i += 1) {
        const { point, value } = points[i];
        if (base === 'window') {
          if (window.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }
      return breakpoint || 'max';
    }
    ",
    "import loadImage from './loadImage.js';
    import preloadImages from './preloadImages.js';
    
    export default {
      loadImage,
      preloadImages,
    };
    ",
    "import { getWindow } from 'ssr-window';
    import $ from '../../shared/dom.js';
    
    export default function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      const window = getWindow();
      let image;
      function onReady() {
        if (callback) callback();
      }
      const isPicture = $(imageEl).parent('picture')[0];
    
      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;
          if (sizes) {
            image.sizes = sizes;
          }
          if (srcset) {
            image.srcset = srcset;
          }
          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }
    ",
    "export default function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');
      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }
      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(
          imageEl,
          imageEl.currentSrc || imageEl.getAttribute('src'),
          imageEl.srcset || imageEl.getAttribute('srcset'),
          imageEl.sizes || imageEl.getAttribute('sizes'),
          true,
          onReady,
        );
      }
    }
    ",
    "import { getDocument } from 'ssr-window';
    
    export default function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document = getDocument();
      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach((key) => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];
            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }
            params[key] = element;
            originalParams[key] = element;
          }
        });
      }
      return params;
    }
    ",
    "export default function classesToSelector(classes = '') {
      return `.${classes
        .trim()
        .replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
        .replace(/ /g, '.')}`;
    }
    ",
    "export default function appendSlide(slides) {
      const swiper = this;
      const { $wrapperEl, params } = swiper;
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
    }
    ",
    "export default function prependSlide(slides) {
      const swiper = this;
      const { params, $wrapperEl, activeIndex } = swiper;
    
      if (params.loop) {
        swiper.loopDestroy();
      }
      let newActiveIndex = activeIndex + 1;
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
      swiper.slideTo(newActiveIndex, 0, false);
    }
    ",
    "export default function addSlide(index, slides) {
      const swiper = this;
      const { $wrapperEl, params, activeIndex } = swiper;
      let activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }
      const baseLength = swiper.slides.length;
      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }
      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }
      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    
      const slidesBuffer = [];
      for (let i = baseLength - 1; i >= index; i -= 1) {
        const currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }
    
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
        newActiveIndex =
          activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }
    
      for (let i = 0; i < slidesBuffer.length; i += 1) {
        $wrapperEl.append(slidesBuffer[i]);
      }
    
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!params.observer) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }
    ",
    "export default function removeSlide(slidesIndexes) {
      const swiper = this;
      const { params, $wrapperEl, activeIndex } = swiper;
    
      let activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }
      let newActiveIndex = activeIndexBuffer;
      let indexToRemove;
    
      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (let i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }
    
      if (params.loop) {
        swiper.loopCreate();
      }
    
      if (!params.observer) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }
    ",
    "export default function removeAllSlides() {
      const swiper = this;
    
      const slidesIndexes = [];
      for (let i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }
      swiper.removeSlide(slidesIndexes);
    }
    ",
    "export default function effectInit(params) {
      const { effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective } = params;
    
      on('beforeInit', () => {
        if (swiper.params.effect !== effect) return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
        if (perspective && perspective()) {
          swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
        }
    
        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    
        Object.assign(swiper.params, overwriteParamsResult);
        Object.assign(swiper.originalParams, overwriteParamsResult);
      });
      on('setTranslate', () => {
        if (swiper.params.effect !== effect) return;
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        if (swiper.params.effect !== effect) return;
        setTransition(duration);
      });
    
      let requireUpdateOnVirtual;
      on('virtualUpdate', () => {
        if (swiper.params.effect !== effect) return;
        if (!swiper.slides.length) {
          requireUpdateOnVirtual = true;
        }
        requestAnimationFrame(() => {
          if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
            setTranslate();
            requireUpdateOnVirtual = false;
          }
        });
      });
    }
    ",
    "export default function effectTarget(effectParams, $slideEl) {
      if (effectParams.transformEl) {
        return $slideEl.find(effectParams.transformEl).css({
          'backface-visibility': 'hidden',
          '-webkit-backface-visibility': 'hidden',
        });
      }
      return $slideEl;
    }
    ",
    "export default function effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides }) {
      const { slides, activeIndex, $wrapperEl } = swiper;
      if (swiper.params.virtualTranslate && duration !== 0) {
        let eventTriggered = false;
        let $transitionEndTarget;
        if (allSlides) {
          $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
        } else {
          $transitionEndTarget = transformEl
            ? slides.eq(activeIndex).find(transformEl)
            : slides.eq(activeIndex);
        }
        $transitionEndTarget.transitionEnd(() => {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
          for (let i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
    ",
    "import $ from './dom.js';
    
    export default function createShadow(params, $slideEl, side) {
      const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
      const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
      let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
    
      if (!$shadowEl.length) {
        $shadowEl = $(`<div class="swiper-slide-shadow${side ? `-${side}` : ''}"></div>`);
        $shadowContainer.append($shadowEl);
      }
      return $shadowEl;
    }
    ",
    "import { getWindow } from 'ssr-window';
    
    export default function Resize({ swiper, on, emit }) {
      const window = getWindow();
      let observer = null;
      let animationFrame = null;
    
      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };
    
      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver((entries) => {
          animationFrame = window.requestAnimationFrame(() => {
            const { width, height } = swiper;
            let newWidth = width;
            let newHeight = height;
            entries.forEach(({ contentBoxSize, contentRect, target }) => {
              if (target && target !== swiper.el) return;
              newWidth = contentRect
                ? contentRect.width
                : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect
                ? contentRect.height
                : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width || newHeight !== height) {
              resizeHandler();
            }
          });
        });
        observer.observe(swiper.el);
      };
    
      const removeObserver = () => {
        if (animationFrame) {
          window.cancelAnimationFrame(animationFrame);
        }
        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };
    
      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };
    
      on('init', () => {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }
        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
    
      on('destroy', () => {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }
    ",
    "import { getWindow } from 'ssr-window';
    
    export default function Observer({ swiper, extendParams, on, emit }) {
      const observers = [];
      const window = getWindow();
      const attach = (target, options = {}) => {
        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations) => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }
          const observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };
    
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
    
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
        });
    
        observers.push(observer);
      };
      const init = () => {
        if (!swiper.params.observer) return;
        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();
          for (let i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        }
        // Observe container
        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren,
        });
    
        // Observe wrapper
        attach(swiper.$wrapperEl[0], { attributes: false });
      };
      const destroy = () => {
        observers.forEach((observer) => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };
    
      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false,
      });
      on('init', init);
      on('destroy', destroy);
    }
    ",
    "// Swiper Class
    import Swiper from './core/core.js';
    
    //IMPORT_MODULES
    
    const modules = [
      //INSTALL_MODULES
    ];
    
    Swiper.use(modules);
    
    //EXPORT
    ",
    "import $ from '../../shared/dom.js';
    import { setCSSProperty } from '../../shared/utils.js';
    
    export default function Virtual({ swiper, extendParams, on, emit }) {
      extendParams({
        virtual: {
          enabled: false,
          slides: [],
          cache: true,
          renderSlide: null,
          renderExternal: null,
          renderExternalUpdate: true,
          addSlidesBefore: 0,
          addSlidesAfter: 0,
        },
      });
    
      let cssModeTimeout;
    
      swiper.virtual = {
        cache: {},
        from: undefined,
        to: undefined,
        slides: [],
        offset: 0,
        slidesGrid: [],
      };
    
      function renderSlide(slide, index) {
        const params = swiper.params.virtual;
        if (params.cache && swiper.virtual.cache[index]) {
          return swiper.virtual.cache[index];
        }
        const $slideEl = params.renderSlide
          ? $(params.renderSlide.call(swiper, slide, index))
          : $(
              `<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`,
            );
        if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
        if (params.cache) swiper.virtual.cache[index] = $slideEl;
        return $slideEl;
      }
    
      function update(force) {
        const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
        const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
        const {
          from: previousFrom,
          to: previousTo,
          slides,
          slidesGrid: previousSlidesGrid,
          offset: previousOffset,
        } = swiper.virtual;
        if (!swiper.params.cssMode) {
          swiper.updateActiveIndex();
        }
    
        const activeIndex = swiper.activeIndex || 0;
    
        let offsetProp;
        if (swiper.rtlTranslate) offsetProp = 'right';
        else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    
        let slidesAfter;
        let slidesBefore;
        if (centeredSlides) {
          slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
          slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
          slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
          slidesBefore = slidesPerGroup + addSlidesBefore;
        }
        const from = Math.max((activeIndex || 0) - slidesBefore, 0);
        const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
        const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    
        Object.assign(swiper.virtual, {
          from,
          to,
          offset,
          slidesGrid: swiper.slidesGrid,
        });
    
        function onRendered() {
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();
          if (swiper.lazy && swiper.params.lazy.enabled) {
            swiper.lazy.load();
          }
          emit('virtualUpdate');
        }
    
        if (previousFrom === from && previousTo === to && !force) {
          if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
            swiper.slides.css(offsetProp, `${offset}px`);
          }
          swiper.updateProgress();
          emit('virtualUpdate');
          return;
        }
        if (swiper.params.virtual.renderExternal) {
          swiper.params.virtual.renderExternal.call(swiper, {
            offset,
            from,
            to,
            slides: (function getSlides() {
              const slidesToRender = [];
              for (let i = from; i <= to; i += 1) {
                slidesToRender.push(slides[i]);
              }
              return slidesToRender;
            })(),
          });
          if (swiper.params.virtual.renderExternalUpdate) {
            onRendered();
          } else {
            emit('virtualUpdate');
          }
          return;
        }
        const prependIndexes = [];
        const appendIndexes = [];
        if (force) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
        } else {
          for (let i = previousFrom; i <= previousTo; i += 1) {
            if (i < from || i > to) {
              swiper.$wrapperEl
                .find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`)
                .remove();
            }
          }
        }
        for (let i = 0; i < slides.length; i += 1) {
          if (i >= from && i <= to) {
            if (typeof previousTo === 'undefined' || force) {
              appendIndexes.push(i);
            } else {
              if (i > previousTo) appendIndexes.push(i);
              if (i < previousFrom) prependIndexes.push(i);
            }
          }
        }
        appendIndexes.forEach((index) => {
          swiper.$wrapperEl.append(renderSlide(slides[index], index));
        });
        prependIndexes
          .sort((a, b) => b - a)
          .forEach((index) => {
            swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
          });
        swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
        onRendered();
      }
    
      function appendSlide(slides) {
        if (typeof slides === 'object' && 'length' in slides) {
          for (let i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.push(slides[i]);
          }
        } else {
          swiper.virtual.slides.push(slides);
        }
        update(true);
      }
      function prependSlide(slides) {
        const activeIndex = swiper.activeIndex;
        let newActiveIndex = activeIndex + 1;
        let numberOfNewSlides = 1;
    
        if (Array.isArray(slides)) {
          for (let i = 0; i < slides.length; i += 1) {
            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
          }
          newActiveIndex = activeIndex + slides.length;
          numberOfNewSlides = slides.length;
        } else {
          swiper.virtual.slides.unshift(slides);
        }
        if (swiper.params.virtual.cache) {
          const cache = swiper.virtual.cache;
          const newCache = {};
          Object.keys(cache).forEach((cachedIndex) => {
            const $cachedEl = cache[cachedIndex];
            const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
            if (cachedElIndex) {
              $cachedEl.attr(
                'data-swiper-slide-index',
                parseInt(cachedElIndex, 10) + numberOfNewSlides,
              );
            }
            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
          });
          swiper.virtual.cache = newCache;
        }
        update(true);
        swiper.slideTo(newActiveIndex, 0);
      }
      function removeSlide(slidesIndexes) {
        if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
        let activeIndex = swiper.activeIndex;
        if (Array.isArray(slidesIndexes)) {
          for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
            swiper.virtual.slides.splice(slidesIndexes[i], 1);
            if (swiper.params.virtual.cache) {
              delete swiper.virtual.cache[slidesIndexes[i]];
            }
            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
          }
        } else {
          swiper.virtual.slides.splice(slidesIndexes, 1);
          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes];
          }
          if (slidesIndexes < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
        update(true);
        swiper.slideTo(activeIndex, 0);
      }
      function removeAllSlides() {
        swiper.virtual.slides = [];
        if (swiper.params.virtual.cache) {
          swiper.virtual.cache = {};
        }
        update(true);
        swiper.slideTo(0, 0);
      }
    
      on('beforeInit', () => {
        if (!swiper.params.virtual.enabled) return;
        swiper.virtual.slides = swiper.params.virtual.slides;
        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
    
        if (!swiper.params.initialSlide) {
          update();
        }
      });
      on('setTranslate', () => {
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode && !swiper._immediateVirtual) {
          clearTimeout(cssModeTimeout);
          cssModeTimeout = setTimeout(() => {
            update();
          }, 100);
        } else {
          update();
        }
      });
      on('init update resize', () => {
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode) {
          setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
        }
      });
    
      Object.assign(swiper.virtual, {
        appendSlide,
        prependSlide,
        removeSlide,
        removeAllSlides,
        update,
      });
    }
    ",
    "/* eslint-disable consistent-return */
    import { getWindow, getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    
    export default function Keyboard({ swiper, extendParams, on, emit }) {
      const document = getDocument();
      const window = getWindow();
      swiper.keyboard = {
        enabled: false,
      };
      extendParams({
        keyboard: {
          enabled: false,
          onlyInViewport: true,
          pageUpDown: true,
        },
      });
    
      function handle(event) {
        if (!swiper.enabled) return;
    
        const { rtlTranslate: rtl } = swiper;
        let e = event;
        if (e.originalEvent) e = e.originalEvent; // jquery fix
        const kc = e.keyCode || e.charCode;
        const pageUpDown = swiper.params.keyboard.pageUpDown;
        const isPageUp = pageUpDown && kc === 33;
        const isPageDown = pageUpDown && kc === 34;
        const isArrowLeft = kc === 37;
        const isArrowRight = kc === 39;
        const isArrowUp = kc === 38;
        const isArrowDown = kc === 40;
        // Directions locks
        if (
          !swiper.allowSlideNext &&
          ((swiper.isHorizontal() && isArrowRight) ||
            (swiper.isVertical() && isArrowDown) ||
            isPageDown)
        ) {
          return false;
        }
        if (
          !swiper.allowSlidePrev &&
          ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)
        ) {
          return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
          return undefined;
        }
        if (
          document.activeElement &&
          document.activeElement.nodeName &&
          (document.activeElement.nodeName.toLowerCase() === 'input' ||
            document.activeElement.nodeName.toLowerCase() === 'textarea')
        ) {
          return undefined;
        }
        if (
          swiper.params.keyboard.onlyInViewport &&
          (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)
        ) {
          let inView = false;
          // Check that swiper should be inside of visible area of window
          if (
            swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 &&
            swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0
          ) {
            return undefined;
          }
    
          const $el = swiper.$el;
          const swiperWidth = $el[0].clientWidth;
          const swiperHeight = $el[0].clientHeight;
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;
          const swiperOffset = swiper.$el.offset();
          if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
          const swiperCoord = [
            [swiperOffset.left, swiperOffset.top],
            [swiperOffset.left + swiperWidth, swiperOffset.top],
            [swiperOffset.left, swiperOffset.top + swiperHeight],
            [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],
          ];
          for (let i = 0; i < swiperCoord.length; i += 1) {
            const point = swiperCoord[i];
            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
              if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
              inView = true;
            }
          }
          if (!inView) return undefined;
        }
        if (swiper.isHorizontal()) {
          if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
          }
          if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl))
            swiper.slideNext();
          if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl))
            swiper.slidePrev();
        } else {
          if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
          }
          if (isPageDown || isArrowDown) swiper.slideNext();
          if (isPageUp || isArrowUp) swiper.slidePrev();
        }
        emit('keyPress', kc);
        return undefined;
      }
      function enable() {
        if (swiper.keyboard.enabled) return;
        $(document).on('keydown', handle);
        swiper.keyboard.enabled = true;
      }
      function disable() {
        if (!swiper.keyboard.enabled) return;
        $(document).off('keydown', handle);
        swiper.keyboard.enabled = false;
      }
    
      on('init', () => {
        if (swiper.params.keyboard.enabled) {
          enable();
        }
      });
      on('destroy', () => {
        if (swiper.keyboard.enabled) {
          disable();
        }
      });
    
      Object.assign(swiper.keyboard, {
        enable,
        disable,
      });
    }
    ",
    "/* eslint-disable consistent-return */
    import { getWindow } from 'ssr-window';
    import $ from '../../shared/dom.js';
    import { now, nextTick } from '../../shared/utils.js';
    
    export default function Mousewheel({ swiper, extendParams, on, emit }) {
      const window = getWindow();
    
      extendParams({
        mousewheel: {
          enabled: false,
          releaseOnEdges: false,
          invert: false,
          forceToAxis: false,
          sensitivity: 1,
          eventsTarget: 'container',
          thresholdDelta: null,
          thresholdTime: null,
        },
      });
    
      swiper.mousewheel = {
        enabled: false,
      };
    
      let timeout;
      let lastScrollTime = now();
      let lastEventBeforeSnap;
      const recentWheelEvents = [];
    
      function normalize(e) {
        // Reasonable defaults
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;
    
        let sX = 0;
        let sY = 0; // spinX, spinY
        let pX = 0;
        let pY = 0; // pixelX, pixelY
    
        // Legacy
        if ('detail' in e) {
          sY = e.detail;
        }
        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }
        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }
        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        }
    
        // side scrolling on FF with DOMMouseScroll
        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }
    
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
    
        if ('deltaY' in e) {
          pY = e.deltaY;
        }
        if ('deltaX' in e) {
          pX = e.deltaX;
        }
    
        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }
    
        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        }
    
        // Fall-back if spin cannot be determined
        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }
    
        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY,
        };
      }
      function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
      }
      function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
      }
      function animateSlider(newEvent) {
        if (
          swiper.params.mousewheel.thresholdDelta &&
          newEvent.delta < swiper.params.mousewheel.thresholdDelta
        ) {
          // Prevent if delta of wheel scroll delta is below configured threshold
          return false;
        }
    
        if (
          swiper.params.mousewheel.thresholdTime &&
          now() - lastScrollTime < swiper.params.mousewheel.thresholdTime
        ) {
          // Prevent if time between scrolls is below configured threshold
          return false;
        }
    
        // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).
        if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
          // Return false as a default
          return true;
        }
        // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.
        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          emit('scroll', newEvent.raw);
        }
        // If you got here is because an animation has been triggered so store the current time
        lastScrollTime = new window.Date().getTime();
        // Return false as a default
        return false;
      }
      function releaseScroll(newEvent) {
        const params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
        return false;
      }
      function handle(event) {
        let e = event;
        let disableParentSwiper = true;
        if (!swiper.enabled) return;
        const params = swiper.params.mousewheel;
    
        if (swiper.params.cssMode) {
          e.preventDefault();
        }
    
        let target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }
        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges)
          return true;
    
        if (e.originalEvent) e = e.originalEvent; // jquery fix
        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    
        const data = normalize(e);
    
        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
            else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
          else return true;
        } else {
          delta =
            Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }
    
        if (delta === 0) return true;
    
        if (params.invert) delta = -delta;
    
        // Get the scroll positions
        let positions = swiper.getTranslate() + delta * params.sensitivity;
    
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
    
        // When loop is true:
        //     the disableParentSwiper will be true.
        // When loop is false:
        //     if the scroll positions is not on edge,
        //     then the disableParentSwiper will be true.
        //     if the scroll on edge positions,
        //     then the disableParentSwiper will be false.
        disableParentSwiper = swiper.params.loop
          ? true
          : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
    
        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
          // Register the new event in a variable which stores the relevant data
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event,
          };
    
          // Keep the most recent events
          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }
          const prevEvent = recentWheelEvents.length
            ? recentWheelEvents[recentWheelEvents.length - 1]
            : undefined;
          recentWheelEvents.push(newEvent);
    
          // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.
          if (prevEvent) {
            if (
              newEvent.direction !== prevEvent.direction ||
              newEvent.delta > prevEvent.delta ||
              newEvent.time > prevEvent.time + 150
            ) {
              animateSlider(newEvent);
            }
          } else {
            animateSlider(newEvent);
          }
    
          // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.
          if (releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:
    
          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          const newEvent = {
            time: now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
          };
          const ignoreWheelEvents =
            lastEventBeforeSnap &&
            newEvent.time < lastEventBeforeSnap.time + 500 &&
            newEvent.delta <= lastEventBeforeSnap.delta &&
            newEvent.direction === lastEventBeforeSnap.direction;
          if (!ignoreWheelEvents) {
            lastEventBeforeSnap = undefined;
    
            if (swiper.params.loop) {
              swiper.loopFix();
            }
            let position = swiper.getTranslate() + delta * params.sensitivity;
            const wasBeginning = swiper.isBeginning;
            const wasEnd = swiper.isEnd;
    
            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
    
            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
    
            if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
              swiper.updateSlidesClasses();
            }
    
            if (swiper.params.freeMode.sticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(timeout);
              timeout = undefined;
              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }
              const prevEvent = recentWheelEvents.length
                ? recentWheelEvents[recentWheelEvents.length - 1]
                : undefined;
              const firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(newEvent);
              if (
                prevEvent &&
                (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)
              ) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (
                recentWheelEvents.length >= 15 &&
                newEvent.time - firstEvent.time < 500 &&
                firstEvent.delta - newEvent.delta >= 1 &&
                newEvent.delta <= 6
              ) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                timeout = nextTick(() => {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }
              if (!timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                timeout = nextTick(() => {
                  const snapToThreshold = 0.5;
                  lastEventBeforeSnap = newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            }
    
            // Emit event
            if (!ignoreWheelEvents) emit('scroll', e);
    
            // Stop autoplay
            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)
              swiper.autoplay.stop();
            // Return page scroll on edge positions
            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }
    
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
      }
    
      function events(method) {
        let target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarget !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarget);
        }
        target[method]('mouseenter', handleMouseEnter);
        target[method]('mouseleave', handleMouseLeave);
        target[method]('wheel', handle);
      }
    
      function enable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener('wheel', handle);
          return true;
        }
        if (swiper.mousewheel.enabled) return false;
        events('on');
        swiper.mousewheel.enabled = true;
        return true;
      }
      function disable() {
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, handle);
          return true;
        }
        if (!swiper.mousewheel.enabled) return false;
        events('off');
        swiper.mousewheel.enabled = false;
        return true;
      }
    
      on('init', () => {
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          disable();
        }
        if (swiper.params.mousewheel.enabled) enable();
      });
      on('destroy', () => {
        if (swiper.params.cssMode) {
          enable();
        }
        if (swiper.mousewheel.enabled) disable();
      });
    
      Object.assign(swiper.mousewheel, {
        enable,
        disable,
      });
    }
    ",
    "import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';
    import $ from '../../shared/dom.js';
    
    export default function Navigation({ swiper, extendParams, on, emit }) {
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
    
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock',
        },
      });
    
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null,
      };
    
      function getEl(el) {
        let $el;
        if (el) {
          $el = $(el);
          if (
            swiper.params.uniqueNavElements &&
            typeof el === 'string' &&
            $el.length > 1 &&
            swiper.$el.find(el).length === 1
          ) {
            $el = swiper.$el.find(el);
          }
        }
        return $el;
      }
    
      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;
        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }
      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        const { $nextEl, $prevEl } = swiper.navigation;
    
        toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
      }
      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
      }
      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
      }
      function init() {
        const params = swiper.params.navigation;
    
        swiper.params.navigation = createElementIfNotDefined(
          swiper,
          swiper.originalParams.navigation,
          swiper.params.navigation,
          {
            nextEl: 'swiper-button-next',
            prevEl: 'swiper-button-prev',
          },
        );
        if (!(params.nextEl || params.prevEl)) return;
    
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);
    
        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }
        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }
    
        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0],
        });
    
        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }
      function destroy() {
        const { $nextEl, $prevEl } = swiper.navigation;
        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }
        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }
    
      on('init', () => {
        init();
        update();
      });
      on('toEdge fromEdge lock unlock', () => {
        update();
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const { $nextEl, $prevEl } = swiper.navigation;
        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', (_s, e) => {
        const { $nextEl, $prevEl } = swiper.navigation;
        const targetEl = e.target;
        if (
          swiper.params.navigation.hideOnClick &&
          !$(targetEl).is($prevEl) &&
          !$(targetEl).is($nextEl)
        ) {
          if (
            swiper.pagination &&
            swiper.params.pagination &&
            swiper.params.pagination.clickable &&
            (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))
          )
            return;
          let isHidden;
          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }
          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }
          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });
    
      Object.assign(swiper.navigation, {
        update,
        init,
        destroy,
      });
    }
    ",
    "import $ from '../../shared/dom.js';
    import classesToSelector from '../../shared/classes-to-selector.js';
    import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';
    
    export default function Pagination({ swiper, extendParams, on, emit }) {
      const pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: (number) => number,
          formatFractionTotal: (number) => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`,
        },
      });
    
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: [],
      };
    
      let bulletSize;
      let dynamicBulletIndex = 0;
    
      function isPaginationDisabled() {
        return (
          !swiper.params.pagination.el ||
          !swiper.pagination.el ||
          !swiper.pagination.$el ||
          swiper.pagination.$el.length === 0
        );
      }
    
      function setSideBullets($bulletEl, position) {
        const { bulletActiveClass } = swiper.params.pagination;
        $bulletEl[position]()
          .addClass(`${bulletActiveClass}-${position}`)
          [position]()
          .addClass(`${bulletActiveClass}-${position}-${position}`);
      }
    
      function update() {
        // Render || Update Pagination bullets/items
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength =
          swiper.virtual && swiper.params.virtual.enabled
            ? swiper.virtual.slides.length
            : swiper.slides.length;
        const $el = swiper.pagination.$el;
        // Current/Total
        let current;
        const total = swiper.params.loop
          ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)
          : swiper.snapGrid.length;
        if (swiper.params.loop) {
          current = Math.ceil(
            (swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup,
          );
          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }
          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        }
        // Types
        if (
          params.type === 'bullets' &&
          swiper.pagination.bullets &&
          swiper.pagination.bullets.length > 0
        ) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;
          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(
              swiper.isHorizontal() ? 'width' : 'height',
              `${bulletSize * (params.dynamicMainBullets + 4)}px`,
            );
            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }
            firstIndex = Math.max(current - dynamicBulletIndex, 0);
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }
          bullets.removeClass(
            ['', '-next', '-next-next', '-prev', '-prev-prev', '-main']
              .map((suffix) => `${params.bulletActiveClass}${suffix}`)
              .join(' '),
          );
          if ($el.length > 1) {
            bullets.each((bullet) => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();
              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }
              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }
                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }
                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);
            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);
              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }
              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }
                  bullets
                    .eq(bullets.length - params.dynamicMainBullets - 1)
                    .addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }
          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset =
              (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }
        if (params.type === 'fraction') {
          $el
            .find(classesToSelector(params.currentClass))
            .text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }
        if (params.type === 'progressbar') {
          let progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }
          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;
          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }
          $el
            .find(classesToSelector(params.progressbarFillClass))
            .transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`)
            .transition(swiper.params.speed);
        }
        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }
      function render() {
        // Render Container
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength =
          swiper.virtual && swiper.params.virtual.enabled
            ? swiper.virtual.slides.length
            : swiper.slides.length;
    
        const $el = swiper.pagination.$el;
        let paginationHTML = '';
        if (params.type === 'bullets') {
          let numberOfBullets = swiper.params.loop
            ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)
            : swiper.snapGrid.length;
          if (
            swiper.params.freeMode &&
            swiper.params.freeMode.enabled &&
            !swiper.params.loop &&
            numberOfBullets > slidesLength
          ) {
            numberOfBullets = slidesLength;
          }
          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }
          $el.html(paginationHTML);
    
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }
        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML =
              `<span class="${params.currentClass}"></span>` +
              ' / ' +
              `<span class="${params.totalClass}"></span>`;
          }
          $el.html(paginationHTML);
        }
        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }
          $el.html(paginationHTML);
        }
        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }
      function init() {
        swiper.params.pagination = createElementIfNotDefined(
          swiper,
          swiper.originalParams.pagination,
          swiper.params.pagination,
          { el: 'swiper-pagination' },
        );
        const params = swiper.params.pagination;
        if (!params.el) return;
    
        let $el = $(params.el);
        if ($el.length === 0) return;
    
        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el);
          // check if it belongs to another nested Swiper
          if ($el.length > 1) {
            $el = $el.filter((el) => {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }
    
        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }
    
        $el.addClass(params.modifierClass + params.type);
        $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    
        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }
    
        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }
    
        Object.assign(swiper.pagination, {
          $el,
          el: $el[0],
        });
    
        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }
      function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const $el = swiper.pagination.$el;
    
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)
          swiper.pagination.bullets.removeClass(params.bulletActiveClass);
        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }
    
      on('init', () => {
        init();
        render();
        update();
      });
      on('activeIndexChange', () => {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', () => {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', () => {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', () => {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const { $el } = swiper.pagination;
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', () => {
        update();
      });
      on('click', (_s, e) => {
        const targetEl = e.target;
        const { $el } = swiper.pagination;
        if (
          swiper.params.pagination.el &&
          swiper.params.pagination.hideOnClick &&
          $el.length > 0 &&
          !$(targetEl).hasClass(swiper.params.pagination.bulletClass)
        ) {
          if (
            swiper.navigation &&
            ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||
              (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
          )
            return;
          const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }
          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });
    
      Object.assign(swiper.pagination, {
        render,
        update,
        init,
        destroy,
      });
    }
    ",
    "import { getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    import { nextTick } from '../../shared/utils.js';
    import createElementIfNotDefined from '../../shared/create-element-if-not-defined.js';
    
    export default function Scrollbar({ swiper, extendParams, on, emit }) {
      const document = getDocument();
    
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
    
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag',
        },
      });
    
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null,
      };
    
      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const { scrollbar, rtlTranslate: rtl, progress } = swiper;
        const { $dragEl, $el } = scrollbar;
        const params = swiper.params.scrollbar;
    
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;
        if (rtl) {
          newPos = -newPos;
          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }
        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }
      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }
      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    
        const { scrollbar } = swiper;
        const { $dragEl, $el } = scrollbar;
    
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    
        divider =
          swiper.size /
          (swiper.virtualSize +
            swiper.params.slidesOffsetBefore -
            (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }
    
        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }
    
        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }
        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }
    
        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](
            swiper.params.scrollbar.lockClass,
          );
        }
      }
      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove'
            ? e.targetTouches[0].clientX
            : e.clientX;
        }
        return e.type === 'touchstart' || e.type === 'touchmove'
          ? e.targetTouches[0].clientY
          : e.clientY;
      }
      function setDragPosition(e) {
        const { scrollbar, rtlTranslate: rtl } = swiper;
        const { $el } = scrollbar;
    
        let positionRatio;
        positionRatio =
          (getPointerPosition(e) -
            $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] -
            (dragStartPos !== null ? dragStartPos : dragSize / 2)) /
          (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
          positionRatio = 1 - positionRatio;
        }
    
        const position =
          swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const { scrollbar, $wrapperEl } = swiper;
        const { $el, $dragEl } = scrollbar;
        isTouched = true;
        dragStartPos =
          e.target === $dragEl[0] || e.target === $dragEl
            ? getPointerPosition(e) -
              e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']
            : null;
        e.preventDefault();
        e.stopPropagation();
    
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
    
        clearTimeout(dragTimeout);
    
        $el.transition(0);
        if (params.hide) {
          $el.css('opacity', 1);
        }
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }
        emit('scrollbarDragStart', e);
      }
      function onDragMove(e) {
        const { scrollbar, $wrapperEl } = swiper;
        const { $el, $dragEl } = scrollbar;
    
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }
      function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const { scrollbar, $wrapperEl } = swiper;
        const { $el } = scrollbar;
    
        if (!isTouched) return;
        isTouched = false;
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }
        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }
        emit('scrollbarDragEnd', e);
        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }
    
      function events(method) {
        const { scrollbar, touchEventsTouch, touchEventsDesktop, params, support } = swiper;
        const $el = scrollbar.$el;
        const target = $el[0];
        const activeListener =
          support.passiveListener && params.passiveListeners
            ? { passive: false, capture: false }
            : false;
        const passiveListener =
          support.passiveListener && params.passiveListeners
            ? { passive: true, capture: false }
            : false;
        if (!target) return;
        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }
    
      function enableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('on');
      }
      function disableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('off');
      }
      function init() {
        const { scrollbar, $el: $swiperEl } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(
          swiper,
          swiper.originalParams.scrollbar,
          swiper.params.scrollbar,
          { el: 'swiper-scrollbar' },
        );
        const params = swiper.params.scrollbar;
        if (!params.el) return;
    
        let $el = $(params.el);
        if (
          swiper.params.uniqueNavElements &&
          typeof params.el === 'string' &&
          $el.length > 1 &&
          $swiperEl.find(params.el).length === 1
        ) {
          $el = $swiperEl.find(params.el);
        }
    
        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }
    
        Object.assign(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0],
        });
    
        if (params.draggable) {
          enableDraggable();
        }
    
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }
      function destroy() {
        disableDraggable();
      }
    
      on('init', () => {
        init();
        updateSize();
        setTranslate();
      });
      on('update resize observerUpdate lock unlock', () => {
        updateSize();
      });
      on('setTranslate', () => {
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        setTransition(duration);
      });
      on('enable disable', () => {
        const { $el } = swiper.scrollbar;
        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', () => {
        destroy();
      });
    
      Object.assign(swiper.scrollbar, {
        updateSize,
        setTranslate,
        init,
        destroy,
      });
    }
    ",
    "import $ from '../../shared/dom.js';
    
    export default function Parallax({ swiper, extendParams, on }) {
      extendParams({
        parallax: {
          enabled: false,
        },
      });
    
      const setTransform = (el, progress) => {
        const { rtl } = swiper;
    
        const $el = $(el);
        const rtlFactor = rtl ? -1 : 1;
    
        const p = $el.attr('data-swiper-parallax') || '0';
        let x = $el.attr('data-swiper-parallax-x');
        let y = $el.attr('data-swiper-parallax-y');
        const scale = $el.attr('data-swiper-parallax-scale');
        const opacity = $el.attr('data-swiper-parallax-opacity');
    
        if (x || y) {
          x = x || '0';
          y = y || '0';
        } else if (swiper.isHorizontal()) {
          x = p;
          y = '0';
        } else {
          y = p;
          x = '0';
        }
    
        if (x.indexOf('%') >= 0) {
          x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
          x = `${x * progress * rtlFactor}px`;
        }
        if (y.indexOf('%') >= 0) {
          y = `${parseInt(y, 10) * progress}%`;
        } else {
          y = `${y * progress}px`;
        }
    
        if (typeof opacity !== 'undefined' && opacity !== null) {
          const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
          $el[0].style.opacity = currentOpacity;
        }
        if (typeof scale === 'undefined' || scale === null) {
          $el.transform(`translate3d(${x}, ${y}, 0px)`);
        } else {
          const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
          $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
        }
      };
    
      const setTranslate = () => {
        const { $el, slides, progress, snapGrid } = swiper;
        $el
          .children(
            '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',
          )
          .each((el) => {
            setTransform(el, progress);
          });
        slides.each((slideEl, slideIndex) => {
          let slideProgress = slideEl.progress;
          if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
            slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
          }
          slideProgress = Math.min(Math.max(slideProgress, -1), 1);
          $(slideEl)
            .find(
              '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',
            )
            .each((el) => {
              setTransform(el, slideProgress);
            });
        });
      };
    
      const setTransition = (duration = swiper.params.speed) => {
        const { $el } = swiper;
        $el
          .find(
            '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]',
          )
          .each((parallaxEl) => {
            const $parallaxEl = $(parallaxEl);
            let parallaxDuration =
              parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
            if (duration === 0) parallaxDuration = 0;
            $parallaxEl.transition(parallaxDuration);
          });
      };
    
      on('beforeInit', () => {
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      });
      on('init', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTranslate', () => {
        if (!swiper.params.parallax.enabled) return;
        setTranslate();
      });
      on('setTransition', (_swiper, duration) => {
        if (!swiper.params.parallax.enabled) return;
        setTransition(duration);
      });
    }
    ",
    "import { getWindow } from 'ssr-window';
    import $ from '../../shared/dom.js';
    import { getTranslate } from '../../shared/utils.js';
    
    export default function Zoom({ swiper, extendParams, on, emit }) {
      const window = getWindow();
      extendParams({
        zoom: {
          enabled: false,
          maxRatio: 3,
          minRatio: 1,
          toggle: true,
          containerClass: 'swiper-zoom-container',
          zoomedSlideClass: 'swiper-slide-zoomed',
        },
      });
    
      swiper.zoom = {
        enabled: false,
      };
    
      let currentScale = 1;
      let isScaling = false;
      let gesturesEnabled;
      let fakeGestureTouched;
      let fakeGestureMoved;
      const gesture = {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      };
      const image = {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      };
      const velocity = {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      };
    
      let scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get() {
          return scale;
        },
        set(value) {
          if (scale !== value) {
            const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;
            const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;
            emit('zoomChange', value, imageEl, slideEl);
          }
          scale = value;
        },
      });
    
      function getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        const x1 = e.targetTouches[0].pageX;
        const y1 = e.targetTouches[0].pageY;
        const x2 = e.targetTouches[1].pageX;
        const y2 = e.targetTouches[1].pageY;
        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        return distance;
      }
    
      // Events
      function onGestureStart(e) {
        const support = swiper.support;
        const params = swiper.params.zoom;
        fakeGestureTouched = false;
        fakeGestureMoved = false;
        if (!support.gestures) {
          if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
            return;
          }
          fakeGestureTouched = true;
          gesture.scaleStart = getDistanceBetweenTouches(e);
        }
        if (!gesture.$slideEl || !gesture.$slideEl.length) {
          gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
          if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          gesture.$imageEl = gesture.$slideEl
            .find(`.${params.containerClass}`)
            .eq(0)
            .find('picture, img, svg, canvas, .swiper-zoom-target')
            .eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
          gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
          if (gesture.$imageWrapEl.length === 0) {
            gesture.$imageEl = undefined;
            return;
          }
        }
        if (gesture.$imageEl) {
          gesture.$imageEl.transition(0);
        }
        isScaling = true;
      }
      function onGestureChange(e) {
        const support = swiper.support;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        if (!support.gestures) {
          if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
            return;
          }
          fakeGestureMoved = true;
          gesture.scaleMove = getDistanceBetweenTouches(e);
        }
    
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
          if (e.type === 'gesturechange') onGestureStart(e);
          return;
        }
        if (support.gestures) {
          zoom.scale = e.scale * currentScale;
        } else {
          zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;
        }
        if (zoom.scale > gesture.maxRatio) {
          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
        }
        if (zoom.scale < params.minRatio) {
          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
        }
        gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      }
      function onGestureEnd(e) {
        const device = swiper.device;
        const support = swiper.support;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        if (!support.gestures) {
          if (!fakeGestureTouched || !fakeGestureMoved) {
            return;
          }
          if (
            e.type !== 'touchend' ||
            (e.type === 'touchend' && e.changedTouches.length < 2 && !device.android)
          ) {
            return;
          }
          fakeGestureTouched = false;
          fakeGestureMoved = false;
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl
          .transition(swiper.params.speed)
          .transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        currentScale = zoom.scale;
        isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = undefined;
      }
      function onTouchStart(e) {
        const device = swiper.device;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (device.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      }
      function onTouchMove(e) {
        const zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;
    
        if (!image.isMoved) {
          image.width = gesture.$imageEl[0].offsetWidth;
          image.height = gesture.$imageEl[0].offsetHeight;
          image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
          image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
          gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
          gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
          gesture.$imageWrapEl.transition(0);
        }
        // Define if we need image drag
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
    
        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
    
        image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
    
        if (!image.isMoved && !isScaling) {
          if (
            swiper.isHorizontal() &&
            ((Math.floor(image.minX) === Math.floor(image.startX) &&
              image.touchesCurrent.x < image.touchesStart.x) ||
              (Math.floor(image.maxX) === Math.floor(image.startX) &&
                image.touchesCurrent.x > image.touchesStart.x))
          ) {
            image.isTouched = false;
            return;
          }
          if (
            !swiper.isHorizontal() &&
            ((Math.floor(image.minY) === Math.floor(image.startY) &&
              image.touchesCurrent.y < image.touchesStart.y) ||
              (Math.floor(image.maxY) === Math.floor(image.startY) &&
                image.touchesCurrent.y > image.touchesStart.y))
          ) {
            image.isTouched = false;
            return;
          }
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        e.stopPropagation();
    
        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
    
        if (image.currentX < image.minX) {
          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
        }
        if (image.currentX > image.maxX) {
          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
        }
    
        if (image.currentY < image.minY) {
          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
        }
        if (image.currentY > image.maxY) {
          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
        }
    
        // Velocity
        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x =
          (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y =
          (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
    
        gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      }
      function onTouchEnd() {
        const zoom = swiper.zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (!image.isTouched || !image.isMoved) {
          image.isTouched = false;
          image.isMoved = false;
          return;
        }
        image.isTouched = false;
        image.isMoved = false;
        let momentumDurationX = 300;
        let momentumDurationY = 300;
        const momentumDistanceX = velocity.x * momentumDurationX;
        const newPositionX = image.currentX + momentumDistanceX;
        const momentumDistanceY = velocity.y * momentumDurationY;
        const newPositionY = image.currentY + momentumDistanceY;
    
        // Fix duration
        if (velocity.x !== 0)
          momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0)
          momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    
        image.currentX = newPositionX;
        image.currentY = newPositionY;
    
        // Define if we need image drag
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    
        gesture.$imageWrapEl
          .transition(momentumDuration)
          .transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      }
      function onTransitionEnd() {
        const zoom = swiper.zoom;
        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
          if (gesture.$imageEl) {
            gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
          }
          if (gesture.$imageWrapEl) {
            gesture.$imageWrapEl.transform('translate3d(0,0,0)');
          }
    
          zoom.scale = 1;
          currentScale = 1;
    
          gesture.$slideEl = undefined;
          gesture.$imageEl = undefined;
          gesture.$imageWrapEl = undefined;
        }
      }
    
      function zoomIn(e) {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
    
        if (!gesture.$slideEl) {
          if (e && e.target) {
            gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
          }
          if (!gesture.$slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
              gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
            } else {
              gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
            }
          }
    
          gesture.$imageEl = gesture.$slideEl
            .find(`.${params.containerClass}`)
            .eq(0)
            .find('picture, img, svg, canvas, .swiper-zoom-target')
            .eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }
        if (
          !gesture.$imageEl ||
          gesture.$imageEl.length === 0 ||
          !gesture.$imageWrapEl ||
          gesture.$imageWrapEl.length === 0
        )
          return;
        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.touchAction = 'none';
        }
    
        gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
    
        let touchX;
        let touchY;
        let offsetX;
        let offsetY;
        let diffX;
        let diffY;
        let translateX;
        let translateY;
        let imageWidth;
        let imageHeight;
        let scaledWidth;
        let scaledHeight;
        let translateMinX;
        let translateMinY;
        let translateMaxX;
        let translateMaxY;
        let slideWidth;
        let slideHeight;
    
        if (typeof image.touchesStart.x === 'undefined' && e) {
          touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
          touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
        } else {
          touchX = image.touchesStart.x;
          touchY = image.touchesStart.y;
        }
    
        zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        if (e) {
          slideWidth = gesture.$slideEl[0].offsetWidth;
          slideHeight = gesture.$slideEl[0].offsetHeight;
          offsetX = gesture.$slideEl.offset().left + window.scrollX;
          offsetY = gesture.$slideEl.offset().top + window.scrollY;
          diffX = offsetX + slideWidth / 2 - touchX;
          diffY = offsetY + slideHeight / 2 - touchY;
    
          imageWidth = gesture.$imageEl[0].offsetWidth;
          imageHeight = gesture.$imageEl[0].offsetHeight;
          scaledWidth = imageWidth * zoom.scale;
          scaledHeight = imageHeight * zoom.scale;
    
          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
          translateMaxX = -translateMinX;
          translateMaxY = -translateMinY;
    
          translateX = diffX * zoom.scale;
          translateY = diffY * zoom.scale;
    
          if (translateX < translateMinX) {
            translateX = translateMinX;
          }
          if (translateX > translateMaxX) {
            translateX = translateMaxX;
          }
    
          if (translateY < translateMinY) {
            translateY = translateMinY;
          }
          if (translateY > translateMaxY) {
            translateY = translateMaxY;
          }
        } else {
          translateX = 0;
          translateY = 0;
        }
        gesture.$imageWrapEl
          .transition(300)
          .transform(`translate3d(${translateX}px, ${translateY}px,0)`);
        gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      }
      function zoomOut() {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
    
        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }
          gesture.$imageEl = gesture.$slideEl
            .find(`.${params.containerClass}`)
            .eq(0)
            .find('picture, img, svg, canvas, .swiper-zoom-target')
            .eq(0);
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }
        if (
          !gesture.$imageEl ||
          gesture.$imageEl.length === 0 ||
          !gesture.$imageWrapEl ||
          gesture.$imageWrapEl.length === 0
        )
          return;
        if (swiper.params.cssMode) {
          swiper.wrapperEl.style.overflow = '';
          swiper.wrapperEl.style.touchAction = '';
        }
        zoom.scale = 1;
        currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
        gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
        gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
        gesture.$slideEl = undefined;
      }
    
      // Toggle Zoom
      function zoomToggle(e) {
        const zoom = swiper.zoom;
    
        if (zoom.scale && zoom.scale !== 1) {
          // Zoom Out
          zoomOut();
        } else {
          // Zoom In
          zoomIn(e);
        }
      }
    
      function getListeners() {
        const support = swiper.support;
        const passiveListener =
          swiper.touchEvents.start === 'touchstart' &&
          support.passiveListener &&
          swiper.params.passiveListeners
            ? { passive: true, capture: false }
            : false;
        const activeListenerWithCapture = support.passiveListener
          ? { passive: false, capture: true }
          : true;
        return { passiveListener, activeListenerWithCapture };
      }
    
      function getSlideSelector() {
        return `.${swiper.params.slideClass}`;
      }
    
      function toggleGestures(method) {
        const { passiveListener } = getListeners();
        const slideSelector = getSlideSelector();
        swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);
        swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);
        swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);
      }
      function enableGestures() {
        if (gesturesEnabled) return;
        gesturesEnabled = true;
        toggleGestures('on');
      }
      function disableGestures() {
        if (!gesturesEnabled) return;
        gesturesEnabled = false;
        toggleGestures('off');
      }
    
      // Attach/Detach Events
      function enable() {
        const zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        const support = swiper.support;
        const { passiveListener, activeListenerWithCapture } = getListeners();
        const slideSelector = getSlideSelector();
    
        // Scale image
        if (support.gestures) {
          swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.on(
            swiper.touchEvents.start,
            slideSelector,
            onGestureStart,
            passiveListener,
          );
          swiper.$wrapperEl.on(
            swiper.touchEvents.move,
            slideSelector,
            onGestureChange,
            activeListenerWithCapture,
          );
          swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.on(
              swiper.touchEvents.cancel,
              slideSelector,
              onGestureEnd,
              passiveListener,
            );
          }
        }
    
        // Move image
        swiper.$wrapperEl.on(
          swiper.touchEvents.move,
          `.${swiper.params.zoom.containerClass}`,
          onTouchMove,
          activeListenerWithCapture,
        );
      }
      function disable() {
        const zoom = swiper.zoom;
        if (!zoom.enabled) return;
        const support = swiper.support;
        zoom.enabled = false;
    
        const { passiveListener, activeListenerWithCapture } = getListeners();
        const slideSelector = getSlideSelector();
    
        // Scale image
        if (support.gestures) {
          swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.off(
            swiper.touchEvents.start,
            slideSelector,
            onGestureStart,
            passiveListener,
          );
          swiper.$wrapperEl.off(
            swiper.touchEvents.move,
            slideSelector,
            onGestureChange,
            activeListenerWithCapture,
          );
          swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.off(
              swiper.touchEvents.cancel,
              slideSelector,
              onGestureEnd,
              passiveListener,
            );
          }
        }
    
        // Move image
        swiper.$wrapperEl.off(
          swiper.touchEvents.move,
          `.${swiper.params.zoom.containerClass}`,
          onTouchMove,
          activeListenerWithCapture,
        );
      }
    
      on('init', () => {
        if (swiper.params.zoom.enabled) {
          enable();
        }
      });
      on('destroy', () => {
        disable();
      });
      on('touchStart', (_s, e) => {
        if (!swiper.zoom.enabled) return;
        onTouchStart(e);
      });
      on('touchEnd', (_s, e) => {
        if (!swiper.zoom.enabled) return;
        onTouchEnd(e);
      });
      on('doubleTap', (_s, e) => {
        if (
          !swiper.animating &&
          swiper.params.zoom.enabled &&
          swiper.zoom.enabled &&
          swiper.params.zoom.toggle
        ) {
          zoomToggle(e);
        }
      });
      on('transitionEnd', () => {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          onTransitionEnd();
        }
      });
      on('slideChange', () => {
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          onTransitionEnd();
        }
      });
    
      Object.assign(swiper.zoom, {
        enable,
        disable,
        in: zoomIn,
        out: zoomOut,
        toggle: zoomToggle,
      });
    }
    ",
    "import { getWindow } from 'ssr-window';
    import $ from '../../shared/dom.js';
    
    export default function Lazy({ swiper, extendParams, on, emit }) {
      extendParams({
        lazy: {
          checkInView: false,
          enabled: false,
          loadPrevNext: false,
          loadPrevNextAmount: 1,
          loadOnTransitionStart: false,
          scrollingElement: '',
    
          elementClass: 'swiper-lazy',
          loadingClass: 'swiper-lazy-loading',
          loadedClass: 'swiper-lazy-loaded',
          preloaderClass: 'swiper-lazy-preloader',
        },
      });
    
      swiper.lazy = {};
    
      let scrollHandlerAttached = false;
      let initialImageLoaded = false;
    
      function loadInSlide(index, loadInDuplicate = true) {
        const params = swiper.params.lazy;
        if (typeof index === 'undefined') return;
        if (swiper.slides.length === 0) return;
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    
        const $slideEl = isVirtual
          ? swiper.$wrapperEl.children(
              `.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`,
            )
          : swiper.slides.eq(index);
    
        const $images = $slideEl.find(
          `.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`,
        );
        if (
          $slideEl.hasClass(params.elementClass) &&
          !$slideEl.hasClass(params.loadedClass) &&
          !$slideEl.hasClass(params.loadingClass)
        ) {
          $images.push($slideEl[0]);
        }
        if ($images.length === 0) return;
    
        $images.each((imageEl) => {
          const $imageEl = $(imageEl);
          $imageEl.addClass(params.loadingClass);
    
          const background = $imageEl.attr('data-background');
          const src = $imageEl.attr('data-src');
          const srcset = $imageEl.attr('data-srcset');
          const sizes = $imageEl.attr('data-sizes');
          const $pictureEl = $imageEl.parent('picture');
    
          swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
            if (
              typeof swiper === 'undefined' ||
              swiper === null ||
              !swiper ||
              (swiper && !swiper.params) ||
              swiper.destroyed
            )
              return;
            if (background) {
              $imageEl.css('background-image', `url("${background}")`);
              $imageEl.removeAttr('data-background');
            } else {
              if (srcset) {
                $imageEl.attr('srcset', srcset);
                $imageEl.removeAttr('data-srcset');
              }
              if (sizes) {
                $imageEl.attr('sizes', sizes);
                $imageEl.removeAttr('data-sizes');
              }
              if ($pictureEl.length) {
                $pictureEl.children('source').each((sourceEl) => {
                  const $source = $(sourceEl);
    
                  if ($source.attr('data-srcset')) {
                    $source.attr('srcset', $source.attr('data-srcset'));
                    $source.removeAttr('data-srcset');
                  }
                });
              }
              if (src) {
                $imageEl.attr('src', src);
                $imageEl.removeAttr('data-src');
              }
            }
    
            $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
            $slideEl.find(`.${params.preloaderClass}`).remove();
            if (swiper.params.loop && loadInDuplicate) {
              const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
              if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                const originalSlide = swiper.$wrapperEl.children(
                  `[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`,
                );
                loadInSlide(originalSlide.index(), false);
              } else {
                const duplicatedSlide = swiper.$wrapperEl.children(
                  `.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`,
                );
                loadInSlide(duplicatedSlide.index(), false);
              }
            }
            emit('lazyImageReady', $slideEl[0], $imageEl[0]);
            if (swiper.params.autoHeight) {
              swiper.updateAutoHeight();
            }
          });
    
          emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
        });
      }
    
      function load() {
        const { $wrapperEl, params: swiperParams, slides, activeIndex } = swiper;
        const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
        const params = swiperParams.lazy;
    
        let slidesPerView = swiperParams.slidesPerView;
        if (slidesPerView === 'auto') {
          slidesPerView = 0;
        }
    
        function slideExist(index) {
          if (isVirtual) {
            if (
              $wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`)
                .length
            ) {
              return true;
            }
          } else if (slides[index]) return true;
          return false;
        }
    
        function slideIndex(slideEl) {
          if (isVirtual) {
            return $(slideEl).attr('data-swiper-slide-index');
          }
          return $(slideEl).index();
        }
    
        if (!initialImageLoaded) initialImageLoaded = true;
        if (swiper.params.watchSlidesProgress) {
          $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {
            const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
            loadInSlide(index);
          });
        } else if (slidesPerView > 1) {
          for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
            if (slideExist(i)) loadInSlide(i);
          }
        } else {
          loadInSlide(activeIndex);
        }
        if (params.loadPrevNext) {
          if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
            const amount = params.loadPrevNextAmount;
            const spv = slidesPerView;
            const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
            const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
            // Next Slides
            for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
              if (slideExist(i)) loadInSlide(i);
            }
            // Prev Slides
            for (let i = minIndex; i < activeIndex; i += 1) {
              if (slideExist(i)) loadInSlide(i);
            }
          } else {
            const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
            if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));
    
            const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
            if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));
          }
        }
      }
      function checkInViewOnLoad() {
        const window = getWindow();
        if (!swiper || swiper.destroyed) return;
        const $scrollElement = swiper.params.lazy.scrollingElement
          ? $(swiper.params.lazy.scrollingElement)
          : $(window);
        const isWindow = $scrollElement[0] === window;
        const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;
        const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;
        const swiperOffset = swiper.$el.offset();
        const { rtlTranslate: rtl } = swiper;
    
        let inView = false;
    
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        const swiperCoord = [
          [swiperOffset.left, swiperOffset.top],
          [swiperOffset.left + swiper.width, swiperOffset.top],
          [swiperOffset.left, swiperOffset.top + swiper.height],
          [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
        ];
        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];
          if (
            point[0] >= 0 &&
            point[0] <= scrollElementWidth &&
            point[1] >= 0 &&
            point[1] <= scrollElementHeight
          ) {
            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
            inView = true;
          }
        }
    
        const passiveListener =
          swiper.touchEvents.start === 'touchstart' &&
          swiper.support.passiveListener &&
          swiper.params.passiveListeners
            ? { passive: true, capture: false }
            : false;
    
        if (inView) {
          load();
          $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);
        } else if (!scrollHandlerAttached) {
          scrollHandlerAttached = true;
          $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);
        }
      }
    
      on('beforeInit', () => {
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      });
      on('init', () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('scroll', () => {
        if (
          swiper.params.freeMode &&
          swiper.params.freeMode.enabled &&
          !swiper.params.freeMode.sticky
        ) {
          load();
        }
      });
      on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('transitionStart', () => {
        if (swiper.params.lazy.enabled) {
          if (
            swiper.params.lazy.loadOnTransitionStart ||
            (!swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded)
          ) {
            if (swiper.params.lazy.checkInView) {
              checkInViewOnLoad();
            } else {
              load();
            }
          }
        }
      });
      on('transitionEnd', () => {
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          if (swiper.params.lazy.checkInView) {
            checkInViewOnLoad();
          } else {
            load();
          }
        }
      });
      on('slideChange', () => {
        const { lazy, cssMode, watchSlidesProgress, touchReleaseOnEdges, resistanceRatio } =
          swiper.params;
        if (
          lazy.enabled &&
          (cssMode || (watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0)))
        ) {
          load();
        }
      });
    
      Object.assign(swiper.lazy, {
        load,
        loadInSlide,
      });
    }
    ",
    "/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
    import { nextTick } from '../../shared/utils.js';
    
    export default function Controller({ swiper, extendParams, on }) {
      extendParams({
        controller: {
          control: undefined,
          inverse: false,
          by: 'slide', // or 'container'
        },
      });
    
      swiper.controller = {
        control: undefined,
      };
    
      function LinearSpline(x, y) {
        const binarySearch = (function search() {
          let maxIndex;
          let minIndex;
          let guess;
          return (array, val) => {
            minIndex = -1;
            maxIndex = array.length;
            while (maxIndex - minIndex > 1) {
              guess = (maxIndex + minIndex) >> 1;
              if (array[guess] <= val) {
                minIndex = guess;
              } else {
                maxIndex = guess;
              }
            }
            return maxIndex;
          };
        })();
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1;
        // Given an x value (x2), return the expected y2 value:
        // (x1,y1) is the known point before given value,
        // (x3,y3) is the known point after given value.
        let i1;
        let i3;
    
        this.interpolate = function interpolate(x2) {
          if (!x2) return 0;
    
          // Get the indexes of x1 and x3 (the array indexes before and after given x2):
          i3 = binarySearch(this.x, x2);
          i1 = i3 - 1;
    
          // We have our indexes i1 & i3, so we can calculate already:
          // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
          return (
            ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1]
          );
        };
        return this;
      }
      // xxx: for now i will just save one spline function to to
      function getInterpolateFunction(c) {
        if (!swiper.controller.spline) {
          swiper.controller.spline = swiper.params.loop
            ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)
            : new LinearSpline(swiper.snapGrid, c.snapGrid);
        }
      }
      function setTranslate(_t, byController) {
        const controlled = swiper.controller.control;
        let multiplier;
        let controlledTranslate;
        const Swiper = swiper.constructor;
        function setControlledTranslate(c) {
          // this will create an Interpolate function based on the snapGrids
          // x is the Grid of the scrolled scroller and y will be the controlled scroller
          // it makes sense to create this only once and recall it for the interpolation
          // the function does a lot of value caching for performance
          const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
          if (swiper.params.controller.by === 'slide') {
            getInterpolateFunction(c);
            // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
            // but it did not work out
            controlledTranslate = -swiper.controller.spline.interpolate(-translate);
          }
    
          if (!controlledTranslate || swiper.params.controller.by === 'container') {
            multiplier =
              (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
          }
    
          if (swiper.params.controller.inverse) {
            controlledTranslate = c.maxTranslate() - controlledTranslate;
          }
          c.updateProgress(controlledTranslate);
          c.setTranslate(controlledTranslate, swiper);
          c.updateActiveIndex();
          c.updateSlidesClasses();
        }
        if (Array.isArray(controlled)) {
          for (let i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTranslate(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTranslate(controlled);
        }
      }
      function setTransition(duration, byController) {
        const Swiper = swiper.constructor;
        const controlled = swiper.controller.control;
        let i;
        function setControlledTransition(c) {
          c.setTransition(duration, swiper);
          if (duration !== 0) {
            c.transitionStart();
            if (c.params.autoHeight) {
              nextTick(() => {
                c.updateAutoHeight();
              });
            }
            c.$wrapperEl.transitionEnd(() => {
              if (!controlled) return;
              if (c.params.loop && swiper.params.controller.by === 'slide') {
                c.loopFix();
              }
              c.transitionEnd();
            });
          }
        }
        if (Array.isArray(controlled)) {
          for (i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTransition(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTransition(controlled);
        }
      }
    
      function removeSpline() {
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      }
      on('beforeInit', () => {
        swiper.controller.control = swiper.params.controller.control;
      });
      on('update', () => {
        removeSpline();
      });
      on('resize', () => {
        removeSpline();
      });
      on('observerUpdate', () => {
        removeSpline();
      });
      on('setTranslate', (_s, translate, byController) => {
        if (!swiper.controller.control) return;
        swiper.controller.setTranslate(translate, byController);
      });
      on('setTransition', (_s, duration, byController) => {
        if (!swiper.controller.control) return;
        swiper.controller.setTransition(duration, byController);
      });
    
      Object.assign(swiper.controller, {
        setTranslate,
        setTransition,
      });
    }
    ",
    "import classesToSelector from '../../shared/classes-to-selector.js';
    import $ from '../../shared/dom.js';
    
    export default function A11y({ swiper, extendParams, on }) {
      extendParams({
        a11y: {
          enabled: true,
          notificationClass: 'swiper-notification',
          prevSlideMessage: 'Previous slide',
          nextSlideMessage: 'Next slide',
          firstSlideMessage: 'This is the first slide',
          lastSlideMessage: 'This is the last slide',
          paginationBulletMessage: 'Go to slide {{index}}',
          slideLabelMessage: '{{index}} / {{slidesLength}}',
          containerMessage: null,
          containerRoleDescriptionMessage: null,
          itemRoleDescriptionMessage: null,
          slideRole: 'group',
          id: null,
        },
      });
    
      let liveRegion = null;
    
      function notify(message) {
        const notification = liveRegion;
        if (notification.length === 0) return;
        notification.html('');
        notification.html(message);
      }
    
      function getRandomNumber(size = 16) {
        const randomChar = () => Math.round(16 * Math.random()).toString(16);
        return 'x'.repeat(size).replace(/x/g, randomChar);
      }
      function makeElFocusable($el) {
        $el.attr('tabIndex', '0');
      }
      function makeElNotFocusable($el) {
        $el.attr('tabIndex', '-1');
      }
      function addElRole($el, role) {
        $el.attr('role', role);
      }
      function addElRoleDescription($el, description) {
        $el.attr('aria-roledescription', description);
      }
      function addElControls($el, controls) {
        $el.attr('aria-controls', controls);
      }
      function addElLabel($el, label) {
        $el.attr('aria-label', label);
      }
      function addElId($el, id) {
        $el.attr('id', id);
      }
      function addElLive($el, live) {
        $el.attr('aria-live', live);
      }
      function disableEl($el) {
        $el.attr('aria-disabled', true);
      }
      function enableEl($el) {
        $el.attr('aria-disabled', false);
      }
    
      function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        const params = swiper.params.a11y;
        const $targetEl = $(e.target);
        if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
          if (!(swiper.isEnd && !swiper.params.loop)) {
            swiper.slideNext();
          }
          if (swiper.isEnd) {
            notify(params.lastSlideMessage);
          } else {
            notify(params.nextSlideMessage);
          }
        }
        if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
          if (!(swiper.isBeginning && !swiper.params.loop)) {
            swiper.slidePrev();
          }
          if (swiper.isBeginning) {
            notify(params.firstSlideMessage);
          } else {
            notify(params.prevSlideMessage);
          }
        }
    
        if (
          swiper.pagination &&
          $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))
        ) {
          $targetEl[0].click();
        }
      }
    
      function updateNavigation() {
        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
        const { $nextEl, $prevEl } = swiper.navigation;
    
        if ($prevEl && $prevEl.length > 0) {
          if (swiper.isBeginning) {
            disableEl($prevEl);
            makeElNotFocusable($prevEl);
          } else {
            enableEl($prevEl);
            makeElFocusable($prevEl);
          }
        }
        if ($nextEl && $nextEl.length > 0) {
          if (swiper.isEnd) {
            disableEl($nextEl);
            makeElNotFocusable($nextEl);
          } else {
            enableEl($nextEl);
            makeElFocusable($nextEl);
          }
        }
      }
    
      function hasPagination() {
        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
      }
    
      function hasClickablePagination() {
        return hasPagination() && swiper.params.pagination.clickable;
      }
    
      function updatePagination() {
        const params = swiper.params.a11y;
        if (!hasPagination()) return;
        swiper.pagination.bullets.each((bulletEl) => {
          const $bulletEl = $(bulletEl);
          if (swiper.params.pagination.clickable) {
            makeElFocusable($bulletEl);
            if (!swiper.params.pagination.renderBullet) {
              addElRole($bulletEl, 'button');
              addElLabel(
                $bulletEl,
                params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1),
              );
            }
          }
          if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
            $bulletEl.attr('aria-current', 'true');
          } else {
            $bulletEl.removeAttr('aria-current');
          }
        });
      }
    
      const initNavEl = ($el, wrapperId, message) => {
        makeElFocusable($el);
        if ($el[0].tagName !== 'BUTTON') {
          addElRole($el, 'button');
          $el.on('keydown', onEnterOrSpaceKey);
        }
        addElLabel($el, message);
        addElControls($el, wrapperId);
      };
    
      const handleFocus = (e) => {
        const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
        if (!slideEl || !swiper.slides.includes(slideEl)) return;
        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
        const isVisible =
          swiper.params.watchSlidesProgress &&
          swiper.visibleSlides &&
          swiper.visibleSlides.includes(slideEl);
        if (isActive || isVisible) return;
        swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
      };
    
      function init() {
        const params = swiper.params.a11y;
    
        swiper.$el.append(liveRegion);
    
        // Container
        const $containerEl = swiper.$el;
        if (params.containerRoleDescriptionMessage) {
          addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
        }
        if (params.containerMessage) {
          addElLabel($containerEl, params.containerMessage);
        }
    
        // Wrapper
        const $wrapperEl = swiper.$wrapperEl;
        const wrapperId = params.id || $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;
        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
        addElId($wrapperEl, wrapperId);
        addElLive($wrapperEl, live);
    
        // Slide
        if (params.itemRoleDescriptionMessage) {
          addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);
        }
        addElRole($(swiper.slides), params.slideRole);
    
        const slidesLength = swiper.params.loop
          ? swiper.slides.filter((el) => !el.classList.contains(swiper.params.slideDuplicateClass))
              .length
          : swiper.slides.length;
        swiper.slides.each((slideEl, index) => {
          const $slideEl = $(slideEl);
          const slideIndex = swiper.params.loop
            ? parseInt($slideEl.attr('data-swiper-slide-index'), 10)
            : index;
          const ariaLabelMessage = params.slideLabelMessage
            .replace(/\{\{index\}\}/, slideIndex + 1)
            .replace(/\{\{slidesLength\}\}/, slidesLength);
          addElLabel($slideEl, ariaLabelMessage);
        });
    
        // Navigation
        let $nextEl;
        let $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }
    
        if ($nextEl && $nextEl.length) {
          initNavEl($nextEl, wrapperId, params.nextSlideMessage);
        }
        if ($prevEl && $prevEl.length) {
          initNavEl($prevEl, wrapperId, params.prevSlideMessage);
        }
    
        // Pagination
        if (hasClickablePagination()) {
          swiper.pagination.$el.on(
            'keydown',
            classesToSelector(swiper.params.pagination.bulletClass),
            onEnterOrSpaceKey,
          );
        }
    
        // Tab focus
        swiper.$el.on('focus', handleFocus, true);
      }
      function destroy() {
        if (liveRegion && liveRegion.length > 0) liveRegion.remove();
    
        let $nextEl;
        let $prevEl;
        if (swiper.navigation && swiper.navigation.$nextEl) {
          $nextEl = swiper.navigation.$nextEl;
        }
        if (swiper.navigation && swiper.navigation.$prevEl) {
          $prevEl = swiper.navigation.$prevEl;
        }
        if ($nextEl) {
          $nextEl.off('keydown', onEnterOrSpaceKey);
        }
        if ($prevEl) {
          $prevEl.off('keydown', onEnterOrSpaceKey);
        }
    
        // Pagination
        if (hasClickablePagination()) {
          swiper.pagination.$el.off(
            'keydown',
            classesToSelector(swiper.params.pagination.bulletClass),
            onEnterOrSpaceKey,
          );
        }
    
        // Tab focus
        swiper.$el.off('focus', handleFocus, true);
      }
    
      on('beforeInit', () => {
        liveRegion = $(
          `<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`,
        );
      });
    
      on('afterInit', () => {
        if (!swiper.params.a11y.enabled) return;
        init();
      });
      on('fromEdge toEdge afterInit lock unlock', () => {
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
      });
      on('paginationUpdate', () => {
        if (!swiper.params.a11y.enabled) return;
        updatePagination();
      });
      on('destroy', () => {
        if (!swiper.params.a11y.enabled) return;
        destroy();
      });
    }
    ",
    "import { getWindow } from 'ssr-window';
    
    export default function History({ swiper, extendParams, on }) {
      extendParams({
        history: {
          enabled: false,
          root: '',
          replaceState: false,
          key: 'slides',
        },
      });
    
      let initialized = false;
      let paths = {};
    
      const slugify = (text) => {
        return text
          .toString()
          .replace(/\s+/g, '-')
          .replace(/[^\w-]+/g, '')
          .replace(/--+/g, '-')
          .replace(/^-+/, '')
          .replace(/-+$/, '');
      };
    
      const getPathValues = (urlOverride) => {
        const window = getWindow();
        let location;
        if (urlOverride) {
          location = new URL(urlOverride);
        } else {
          location = window.location;
        }
        const pathArray = location.pathname
          .slice(1)
          .split('/')
          .filter((part) => part !== '');
        const total = pathArray.length;
        const key = pathArray[total - 2];
        const value = pathArray[total - 1];
        return { key, value };
      };
      const setHistory = (key, index) => {
        const window = getWindow();
        if (!initialized || !swiper.params.history.enabled) return;
        let location;
        if (swiper.params.url) {
          location = new URL(swiper.params.url);
        } else {
          location = window.location;
        }
        const slide = swiper.slides.eq(index);
        let value = slugify(slide.attr('data-history'));
        if (swiper.params.history.root.length > 0) {
          let root = swiper.params.history.root;
          if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
          value = `${root}/${key}/${value}`;
        } else if (!location.pathname.includes(key)) {
          value = `${key}/${value}`;
        }
        const currentState = window.history.state;
        if (currentState && currentState.value === value) {
          return;
        }
        if (swiper.params.history.replaceState) {
          window.history.replaceState({ value }, null, value);
        } else {
          window.history.pushState({ value }, null, value);
        }
      };
    
      const scrollToSlide = (speed, value, runCallbacks) => {
        if (value) {
          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
            const slide = swiper.slides.eq(i);
            const slideHistory = slugify(slide.attr('data-history'));
            if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
              const index = slide.index();
              swiper.slideTo(index, speed, runCallbacks);
            }
          }
        } else {
          swiper.slideTo(0, speed, runCallbacks);
        }
      };
    
      const setHistoryPopState = () => {
        paths = getPathValues(swiper.params.url);
        scrollToSlide(swiper.params.speed, swiper.paths.value, false);
      };
    
      const init = () => {
        const window = getWindow();
        if (!swiper.params.history) return;
        if (!window.history || !window.history.pushState) {
          swiper.params.history.enabled = false;
          swiper.params.hashNavigation.enabled = true;
          return;
        }
        initialized = true;
        paths = getPathValues(swiper.params.url);
        if (!paths.key && !paths.value) return;
        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
        if (!swiper.params.history.replaceState) {
          window.addEventListener('popstate', setHistoryPopState);
        }
      };
      const destroy = () => {
        const window = getWindow();
        if (!swiper.params.history.replaceState) {
          window.removeEventListener('popstate', setHistoryPopState);
        }
      };
    
      on('init', () => {
        if (swiper.params.history.enabled) {
          init();
        }
      });
      on('destroy', () => {
        if (swiper.params.history.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', () => {
        if (initialized) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
      on('slideChange', () => {
        if (initialized && swiper.params.cssMode) {
          setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      });
    }
    ",
    "import { getWindow, getDocument } from 'ssr-window';
    import $ from '../../shared/dom.js';
    
    export default function HashNavigation({ swiper, extendParams, emit, on }) {
      let initialized = false;
      const document = getDocument();
      const window = getWindow();
      extendParams({
        hashNavigation: {
          enabled: false,
          replaceState: false,
          watchState: false,
        },
      });
      const onHashChange = () => {
        emit('hashChange');
        const newHash = document.location.hash.replace('#', '');
        const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
        if (newHash !== activeSlideHash) {
          const newIndex = swiper.$wrapperEl
            .children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`)
            .index();
          if (typeof newIndex === 'undefined') return;
          swiper.slideTo(newIndex);
        }
      };
      const setHash = () => {
        if (!initialized || !swiper.params.hashNavigation.enabled) return;
        if (
          swiper.params.hashNavigation.replaceState &&
          window.history &&
          window.history.replaceState
        ) {
          window.history.replaceState(
            null,
            null,
            `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '',
          );
          emit('hashSet');
        } else {
          const slide = swiper.slides.eq(swiper.activeIndex);
          const hash = slide.attr('data-hash') || slide.attr('data-history');
          document.location.hash = hash || '';
          emit('hashSet');
        }
      };
      const init = () => {
        if (
          !swiper.params.hashNavigation.enabled ||
          (swiper.params.history && swiper.params.history.enabled)
        )
          return;
        initialized = true;
        const hash = document.location.hash.replace('#', '');
        if (hash) {
          const speed = 0;
          for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
            const slide = swiper.slides.eq(i);
            const slideHash = slide.attr('data-hash') || slide.attr('data-history');
            if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
              const index = slide.index();
              swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
            }
          }
        }
        if (swiper.params.hashNavigation.watchState) {
          $(window).on('hashchange', onHashChange);
        }
      };
      const destroy = () => {
        if (swiper.params.hashNavigation.watchState) {
          $(window).off('hashchange', onHashChange);
        }
      };
    
      on('init', () => {
        if (swiper.params.hashNavigation.enabled) {
          init();
        }
      });
      on('destroy', () => {
        if (swiper.params.hashNavigation.enabled) {
          destroy();
        }
      });
      on('transitionEnd _freeModeNoMomentumRelease', () => {
        if (initialized) {
          setHash();
        }
      });
      on('slideChange', () => {
        if (initialized && swiper.params.cssMode) {
          setHash();
        }
      });
    }
    ",
    "/* eslint no-underscore-dangle: "off" */
    /* eslint no-use-before-define: "off" */
    import { getDocument } from 'ssr-window';
    import { nextTick } from '../../shared/utils.js';
    
    export default function Autoplay({ swiper, extendParams, on, emit }) {
      let timeout;
    
      swiper.autoplay = {
        running: false,
        paused: false,
      };
    
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false,
        },
      });
    
      function run() {
        const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        let delay = swiper.params.autoplay.delay;
        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }
        clearTimeout(timeout);
        timeout = nextTick(() => {
          let autoplayResult;
          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.isBeginning) {
              autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
              emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              autoplayResult = swiper.slideTo(
                swiper.slides.length - 1,
                swiper.params.speed,
                true,
                true,
              );
              emit('autoplay');
            } else {
              stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.isEnd) {
            autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
            emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
            emit('autoplay');
          } else {
            stop();
          }
          if (swiper.params.cssMode && swiper.autoplay.running) run();
          else if (autoplayResult === false) {
            run();
          }
        }, delay);
      }
      function start() {
        if (typeof timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        emit('autoplayStart');
        run();
        return true;
      }
      function stop() {
        if (!swiper.autoplay.running) return false;
        if (typeof timeout === 'undefined') return false;
    
        if (timeout) {
          clearTimeout(timeout);
          timeout = undefined;
        }
        swiper.autoplay.running = false;
        emit('autoplayStop');
        return true;
      }
      function pause(speed) {
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (timeout) clearTimeout(timeout);
        swiper.autoplay.paused = true;
        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          run();
        } else {
          ['transitionend', 'webkitTransitionEnd'].forEach((event) => {
            swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
          });
        }
      }
      function onVisibilityChange() {
        const document = getDocument();
        if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
          pause();
        }
        if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
          run();
          swiper.autoplay.paused = false;
        }
      }
      function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
        if (e.target !== swiper.$wrapperEl[0]) return;
        ['transitionend', 'webkitTransitionEnd'].forEach((event) => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
        swiper.autoplay.paused = false;
        if (!swiper.autoplay.running) {
          stop();
        } else {
          run();
        }
      }
      function onMouseEnter() {
        if (swiper.params.autoplay.disableOnInteraction) {
          stop();
        } else {
          emit('autoplayPause');
          pause();
        }
    
        ['transitionend', 'webkitTransitionEnd'].forEach((event) => {
          swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
        });
      }
      function onMouseLeave() {
        if (swiper.params.autoplay.disableOnInteraction) {
          return;
        }
        swiper.autoplay.paused = false;
        emit('autoplayResume');
        run();
      }
      function attachMouseEvents() {
        if (swiper.params.autoplay.pauseOnMouseEnter) {
          swiper.$el.on('mouseenter', onMouseEnter);
          swiper.$el.on('mouseleave', onMouseLeave);
        }
      }
      function detachMouseEvents() {
        swiper.$el.off('mouseenter', onMouseEnter);
        swiper.$el.off('mouseleave', onMouseLeave);
      }
    
      on('init', () => {
        if (swiper.params.autoplay.enabled) {
          start();
          const document = getDocument();
          document.addEventListener('visibilitychange', onVisibilityChange);
          attachMouseEvents();
        }
      });
      on('beforeTransitionStart', (_s, speed, internal) => {
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            stop();
          }
        }
      });
      on('sliderFirstMove', () => {
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            stop();
          } else {
            pause();
          }
        }
      });
      on('touchEnd', () => {
        if (
          swiper.params.cssMode &&
          swiper.autoplay.paused &&
          !swiper.params.autoplay.disableOnInteraction
        ) {
          run();
        }
      });
      on('destroy', () => {
        detachMouseEvents();
        if (swiper.autoplay.running) {
          stop();
        }
        const document = getDocument();
        document.removeEventListener('visibilitychange', onVisibilityChange);
      });
    
      Object.assign(swiper.autoplay, {
        pause,
        run,
        start,
        stop,
      });
    }
    ",
    "import { isObject } from '../../shared/utils.js';
    import $ from '../../shared/dom.js';
    
    export default function Thumb({ swiper, extendParams, on }) {
      extendParams({
        thumbs: {
          swiper: null,
          multipleActiveThumbs: true,
          autoScrollOffset: 0,
          slideThumbActiveClass: 'swiper-slide-thumb-active',
          thumbsContainerClass: 'swiper-thumbs',
        },
      });
    
      let initialized = false;
      let swiperCreated = false;
    
      swiper.thumbs = {
        swiper: null,
      };
    
      function onThumbClick() {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    
        const clickedIndex = thumbsSwiper.clickedIndex;
        const clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass))
          return;
        if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
        let slideToIndex;
        if (thumbsSwiper.params.loop) {
          slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        } else {
          slideToIndex = clickedIndex;
        }
        if (swiper.params.loop) {
          let currentIndex = swiper.activeIndex;
          if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
            swiper.loopFix();
            // eslint-disable-next-line
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            currentIndex = swiper.activeIndex;
          }
          const prevIndex = swiper.slides
            .eq(currentIndex)
            .prevAll(`[data-swiper-slide-index="${slideToIndex}"]`)
            .eq(0)
            .index();
          const nextIndex = swiper.slides
            .eq(currentIndex)
            .nextAll(`[data-swiper-slide-index="${slideToIndex}"]`)
            .eq(0)
            .index();
          if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
          else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
          else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
          else slideToIndex = prevIndex;
        }
        swiper.slideTo(slideToIndex);
      }
    
      function init() {
        const { thumbs: thumbsParams } = swiper.params;
        if (initialized) return false;
        initialized = true;
        const SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
          swiper.thumbs.swiper = thumbsParams.swiper;
          Object.assign(swiper.thumbs.swiper.originalParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false,
          });
          Object.assign(swiper.thumbs.swiper.params, {
            watchSlidesProgress: true,
            slideToClickedSlide: false,
          });
        } else if (isObject(thumbsParams.swiper)) {
          const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
          Object.assign(thumbsSwiperParams, {
            watchSlidesProgress: true,
            slideToClickedSlide: false,
          });
          swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
          swiperCreated = true;
        }
        swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on('tap', onThumbClick);
        return true;
      }
    
      function update(initial) {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    
        const slidesPerView =
          thumbsSwiper.params.slidesPerView === 'auto'
            ? thumbsSwiper.slidesPerViewDynamic()
            : thumbsSwiper.params.slidesPerView;
    
        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
          let currentThumbsIndex = thumbsSwiper.activeIndex;
          let newThumbsIndex;
          let direction;
          if (thumbsSwiper.params.loop) {
            if (
              thumbsSwiper.slides
                .eq(currentThumbsIndex)
                .hasClass(thumbsSwiper.params.slideDuplicateClass)
            ) {
              thumbsSwiper.loopFix();
              // eslint-disable-next-line
              thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
              currentThumbsIndex = thumbsSwiper.activeIndex;
            }
            // Find actual thumbs index to slide to
            const prevThumbsIndex = thumbsSwiper.slides
              .eq(currentThumbsIndex)
              .prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`)
              .eq(0)
              .index();
            const nextThumbsIndex = thumbsSwiper.slides
              .eq(currentThumbsIndex)
              .nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`)
              .eq(0)
              .index();
            if (typeof prevThumbsIndex === 'undefined') {
              newThumbsIndex = nextThumbsIndex;
            } else if (typeof nextThumbsIndex === 'undefined') {
              newThumbsIndex = prevThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex =
                thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
            } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
              newThumbsIndex = nextThumbsIndex;
            } else {
              newThumbsIndex = prevThumbsIndex;
            }
            direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
          } else {
            newThumbsIndex = swiper.realIndex;
            direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
          }
          if (useOffset) {
            newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
          }
    
          if (
            thumbsSwiper.visibleSlidesIndexes &&
            thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0
          ) {
            if (thumbsSwiper.params.centeredSlides) {
              if (newThumbsIndex > currentThumbsIndex) {
                newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
              } else {
                newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
              }
            } else if (
              newThumbsIndex > currentThumbsIndex &&
              thumbsSwiper.params.slidesPerGroup === 1
            ) {
              // newThumbsIndex = newThumbsIndex - slidesPerView + 1;
            }
            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
          }
        }
    
        // Activate thumbs
        let thumbsToActivate = 1;
        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
          thumbsToActivate = swiper.params.slidesPerView;
        }
    
        if (!swiper.params.thumbs.multipleActiveThumbs) {
          thumbsToActivate = 1;
        }
    
        thumbsToActivate = Math.floor(thumbsToActivate);
    
        thumbsSwiper.slides.removeClass(thumbActiveClass);
        if (
          thumbsSwiper.params.loop ||
          (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)
        ) {
          for (let i = 0; i < thumbsToActivate; i += 1) {
            thumbsSwiper.$wrapperEl
              .children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`)
              .addClass(thumbActiveClass);
          }
        } else {
          for (let i = 0; i < thumbsToActivate; i += 1) {
            thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
          }
        }
      }
    
      on('beforeInit', () => {
        const { thumbs } = swiper.params;
        if (!thumbs || !thumbs.swiper) return;
        init();
        update(true);
      });
      on('slideChange update resize observerUpdate', () => {
        update();
      });
      on('setTransition', (_s, duration) => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        thumbsSwiper.setTransition(duration);
      });
      on('beforeDestroy', () => {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        if (swiperCreated) {
          thumbsSwiper.destroy();
        }
      });
    
      Object.assign(swiper.thumbs, {
        init,
        update,
      });
    }
    ",
    "import { now } from '../../shared/utils.js';
    
    export default function freeMode({ swiper, extendParams, emit, once }) {
      extendParams({
        freeMode: {
          enabled: false,
          momentum: true,
          momentumRatio: 1,
          momentumBounce: true,
          momentumBounceRatio: 1,
          momentumVelocityRatio: 1,
          sticky: false,
          minimumVelocity: 0.02,
        },
      });
    
      function onTouchStart() {
        const translate = swiper.getTranslate();
        swiper.setTranslate(translate);
        swiper.setTransition(0);
        swiper.touchEventsData.velocities.length = 0;
        swiper.freeMode.onTouchEnd({ currentPos: swiper.rtl ? swiper.translate : -swiper.translate });
      }
    
      function onTouchMove() {
        const { touchEventsData: data, touches } = swiper;
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime,
          });
        }
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now(),
        });
      }
    
      function onTouchEnd({ currentPos }) {
        const { params, $wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper;
        // Time diff
        const touchEndTime = now();
        const timeDiff = touchEndTime - data.touchStartTime;
    
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }
          return;
        }
    
        if (params.freeMode.momentum) {
          if (data.velocities.length > 1) {
            const lastMoveEvent = data.velocities.pop();
            const velocityEvent = data.velocities.pop();
    
            const distance = lastMoveEvent.position - velocityEvent.position;
            const time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;
            if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
              swiper.velocity = 0;
            }
            // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.
            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }
          swiper.velocity *= params.freeMode.momentumVelocityRatio;
    
          data.velocities.length = 0;
          let momentumDuration = 1000 * params.freeMode.momentumRatio;
          const momentumDistance = swiper.velocity * momentumDuration;
    
          let newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
    
          let doBounce = false;
          let afterBouncePosition;
          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
          let needsLoopFix;
          if (newPosition < swiper.maxTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }
              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeMode.momentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }
              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeMode.sticky) {
            let nextSlide;
            for (let j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }
    
            if (
              Math.abs(snapGrid[nextSlide] - newPosition) <
                Math.abs(snapGrid[nextSlide - 1] - newPosition) ||
              swiper.swipeDirection === 'next'
            ) {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }
            newPosition = -newPosition;
          }
          if (needsLoopFix) {
            once('transitionEnd', () => {
              swiper.loopFix();
            });
          }
          // Fix duration
          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }
            if (params.freeMode.sticky) {
              // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
          }
    
          if (params.freeMode.momentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(() => {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(() => {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }
    
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          emit('_freeModeNoMomentumRelease');
        }
    
        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
      }
    
      Object.assign(swiper, {
        freeMode: {
          onTouchStart,
          onTouchMove,
          onTouchEnd,
        },
      });
    }
    ",
    "export default function Grid({ swiper, extendParams }) {
      extendParams({
        grid: {
          rows: 1,
          fill: 'column',
        },
      });
    
      let slidesNumberEvenToRows;
      let slidesPerRow;
      let numFullColumns;
    
      const initSlides = (slidesLength) => {
        const { slidesPerView } = swiper.params;
        const { rows, fill } = swiper.params.grid;
        slidesPerRow = slidesNumberEvenToRows / rows;
        numFullColumns = Math.floor(slidesLength / rows);
        if (Math.floor(slidesLength / rows) === slidesLength / rows) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
        }
        if (slidesPerView !== 'auto' && fill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
        }
      };
    
      const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
        const { slidesPerGroup, spaceBetween } = swiper.params;
        const { rows, fill } = swiper.params.grid;
        // Set slides order
        let newSlideOrderIndex;
        let column;
        let row;
        if (fill === 'row' && slidesPerGroup > 1) {
          const groupIndex = Math.floor(i / (slidesPerGroup * rows));
          const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
          const columnsInGroup =
            groupIndex === 0
              ? slidesPerGroup
              : Math.min(
                  Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows),
                  slidesPerGroup,
                );
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
    
          newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;
          slide.css({
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
        } else if (fill === 'column') {
          column = Math.floor(i / rows);
          row = i - column * rows;
          if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {
            row += 1;
            if (row >= rows) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }
        slide.css(
          getDirectionLabel('margin-top'),
          row !== 0 ? spaceBetween && `${spaceBetween}px` : '',
        );
      };
    
      const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
        const { spaceBetween, centeredSlides, roundLengths } = swiper.params;
        const { rows } = swiper.params.grid;
        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
        swiper.$wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`,
        });
        if (centeredSlides) {
          snapGrid.splice(0, snapGrid.length);
          const newSlidesGrid = [];
          for (let i = 0; i < snapGrid.length; i += 1) {
            let slidesGridItem = snapGrid[i];
            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }
          snapGrid.push(...newSlidesGrid);
        }
      };
    
      swiper.grid = {
        initSlides,
        updateSlide,
        updateWrapperSize,
      };
    }
    ",
    "import appendSlide from './methods/appendSlide.js';
    import prependSlide from './methods/prependSlide.js';
    import addSlide from './methods/addSlide.js';
    import removeSlide from './methods/removeSlide.js';
    import removeAllSlides from './methods/removeAllSlides.js';
    
    export default function Manipulation({ swiper }) {
      Object.assign(swiper, {
        appendSlide: appendSlide.bind(swiper),
        prependSlide: prependSlide.bind(swiper),
        addSlide: addSlide.bind(swiper),
        removeSlide: removeSlide.bind(swiper),
        removeAllSlides: removeAllSlides.bind(swiper),
      });
    }
    ",
    "import effectInit from '../../shared/effect-init.js';
    import effectTarget from '../../shared/effect-target.js';
    import effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';
    
    export default function EffectFade({ swiper, extendParams, on }) {
      extendParams({
        fadeEffect: {
          crossFade: false,
          transformEl: null,
        },
      });
    
      const setTranslate = () => {
        const { slides } = swiper;
        const params = swiper.params.fadeEffect;
        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = swiper.slides.eq(i);
          const offset = $slideEl[0].swiperSlideOffset;
          let tx = -offset;
          if (!swiper.params.virtualTranslate) tx -= swiper.translate;
          let ty = 0;
          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
          }
          const slideOpacity = swiper.params.fadeEffect.crossFade
            ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
            : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
    
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl
            .css({
              opacity: slideOpacity,
            })
            .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
        }
      };
      const setTransition = (duration) => {
        const { transformEl } = swiper.params.fadeEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration);
        effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides: true });
      };
    
      effectInit({
        effect: 'fade',
        swiper,
        on,
        setTranslate,
        setTransition,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: !swiper.params.cssMode,
        }),
      });
    }
    ",
    "import $ from '../../shared/dom.js';
    import effectInit from '../../shared/effect-init.js';
    
    export default function EffectCube({ swiper, extendParams, on }) {
      extendParams({
        cubeEffect: {
          slideShadows: true,
          shadow: true,
          shadowOffset: 20,
          shadowScale: 0.94,
        },
      });
    
      const setTranslate = () => {
        const {
          $el,
          $wrapperEl,
          slides,
          width: swiperWidth,
          height: swiperHeight,
          rtlTranslate: rtl,
          size: swiperSize,
          browser,
        } = swiper;
        const params = swiper.params.cubeEffect;
        const isHorizontal = swiper.isHorizontal();
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let wrapperRotate = 0;
        let $cubeShadowEl;
        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $wrapperEl.append($cubeShadowEl);
            }
            $cubeShadowEl.css({ height: `${swiperWidth}px` });
          } else {
            $cubeShadowEl = $el.find('.swiper-cube-shadow');
            if ($cubeShadowEl.length === 0) {
              $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
              $el.append($cubeShadowEl);
            }
          }
        }
        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          let slideIndex = i;
          if (isVirtual) {
            slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
          }
          let slideAngle = slideIndex * 90;
          let round = Math.floor(slideAngle / 360);
          if (rtl) {
            slideAngle = -slideAngle;
            round = Math.floor(-slideAngle / 360);
          }
          const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          let tx = 0;
          let ty = 0;
          let tz = 0;
          if (slideIndex % 4 === 0) {
            tx = -round * 4 * swiperSize;
            tz = 0;
          } else if ((slideIndex - 1) % 4 === 0) {
            tx = 0;
            tz = -round * 4 * swiperSize;
          } else if ((slideIndex - 2) % 4 === 0) {
            tx = swiperSize + round * 4 * swiperSize;
            tz = swiperSize;
          } else if ((slideIndex - 3) % 4 === 0) {
            tx = -swiperSize;
            tz = 3 * swiperSize + swiperSize * 4 * round;
          }
          if (rtl) {
            tx = -tx;
          }
    
          if (!isHorizontal) {
            ty = tx;
            tx = 0;
          }
    
          const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${
            isHorizontal ? slideAngle : 0
          }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
          if (progress <= 1 && progress > -1) {
            wrapperRotate = slideIndex * 90 + progress * 90;
            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
          }
          $slideEl.transform(transform);
          if (params.slideShadows) {
            // Set shadows
            let shadowBefore = isHorizontal
              ? $slideEl.find('.swiper-slide-shadow-left')
              : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = isHorizontal
              ? $slideEl.find('.swiper-slide-shadow-right')
              : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
              shadowBefore = $(
                `<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`,
              );
              $slideEl.append(shadowBefore);
            }
            if (shadowAfter.length === 0) {
              shadowAfter = $(
                `<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`,
              );
              $slideEl.append(shadowAfter);
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }
        $wrapperEl.css({
          '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
          'transform-origin': `50% 50% -${swiperSize / 2}px`,
        });
    
        if (params.shadow) {
          if (isHorizontal) {
            $cubeShadowEl.transform(
              `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${
                -swiperWidth / 2
              }px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`,
            );
          } else {
            const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
            const multiplier =
              1.5 -
              (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +
                Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);
            const scale1 = params.shadowScale;
            const scale2 = params.shadowScale / multiplier;
            const offset = params.shadowOffset;
            $cubeShadowEl.transform(
              `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${
                -swiperHeight / 2 / scale2
              }px) rotateX(-90deg)`,
            );
          }
        }
        const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;
        $wrapperEl.transform(
          `translate3d(0px,0,${zFactor}px) rotateX(${
            swiper.isHorizontal() ? 0 : wrapperRotate
          }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`,
        );
      };
      const setTransition = (duration) => {
        const { $el, slides } = swiper;
        slides
          .transition(duration)
          .find(
            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',
          )
          .transition(duration);
        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
          $el.find('.swiper-cube-shadow').transition(duration);
        }
      };
    
      effectInit({
        effect: 'cube',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true,
        }),
      });
    }
    ",
    "import createShadow from '../../shared/create-shadow.js';
    import effectInit from '../../shared/effect-init.js';
    import effectTarget from '../../shared/effect-target.js';
    import effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';
    
    export default function EffectFlip({ swiper, extendParams, on }) {
      extendParams({
        flipEffect: {
          slideShadows: true,
          limitRotation: true,
          transformEl: null,
        },
      });
    
      const setTranslate = () => {
        const { slides, rtlTranslate: rtl } = swiper;
        const params = swiper.params.flipEffect;
        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          let progress = $slideEl[0].progress;
          if (swiper.params.flipEffect.limitRotation) {
            progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
          }
          const offset = $slideEl[0].swiperSlideOffset;
          const rotate = -180 * progress;
          let rotateY = rotate;
          let rotateX = 0;
          let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
          let ty = 0;
          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
            rotateX = -rotateY;
            rotateY = 0;
          } else if (rtl) {
            rotateY = -rotateY;
          }
    
          $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
    
          if (params.slideShadows) {
            // Set shadows
            let shadowBefore = swiper.isHorizontal()
              ? $slideEl.find('.swiper-slide-shadow-left')
              : $slideEl.find('.swiper-slide-shadow-top');
            let shadowAfter = swiper.isHorizontal()
              ? $slideEl.find('.swiper-slide-shadow-right')
              : $slideEl.find('.swiper-slide-shadow-bottom');
            if (shadowBefore.length === 0) {
              shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');
            }
            if (shadowAfter.length === 0) {
              shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
            }
            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
          const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform);
        }
      };
    
      const setTransition = (duration) => {
        const { transformEl } = swiper.params.flipEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements
          .transition(duration)
          .find(
            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',
          )
          .transition(duration);
        effectVirtualTransitionEnd({ swiper, duration, transformEl });
      };
    
      effectInit({
        effect: 'flip',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          slidesPerView: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: !swiper.params.cssMode,
        }),
      });
    }
    ",
    "import createShadow from '../../shared/create-shadow.js';
    import effectInit from '../../shared/effect-init.js';
    import effectTarget from '../../shared/effect-target.js';
    
    export default function EffectCoverflow({ swiper, extendParams, on }) {
      extendParams({
        coverflowEffect: {
          rotate: 50,
          stretch: 0,
          depth: 100,
          scale: 1,
          modifier: 1,
          slideShadows: true,
          transformEl: null,
        },
      });
    
      const setTranslate = () => {
        const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;
        const params = swiper.params.coverflowEffect;
        const isHorizontal = swiper.isHorizontal();
        const transform = swiper.translate;
        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
        const rotate = isHorizontal ? params.rotate : -params.rotate;
        const translate = params.depth;
        // Each slide offset from center
        for (let i = 0, length = slides.length; i < length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideSize = slidesSizesGrid[i];
          const slideOffset = $slideEl[0].swiperSlideOffset;
          const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
          const offsetMultiplier =
            typeof params.modifier === 'function'
              ? params.modifier(centerOffset)
              : centerOffset * params.modifier;
    
          let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
          let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
          // var rotateZ = 0
          let translateZ = -translate * Math.abs(offsetMultiplier);
    
          let stretch = params.stretch;
          // Allow percentage to make a relative stretch for responsive sliders
          if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
            stretch = (parseFloat(params.stretch) / 100) * slideSize;
          }
          let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
          let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
    
          let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
    
          // Fix for ultra small values
          if (Math.abs(translateX) < 0.001) translateX = 0;
          if (Math.abs(translateY) < 0.001) translateY = 0;
          if (Math.abs(translateZ) < 0.001) translateZ = 0;
          if (Math.abs(rotateY) < 0.001) rotateY = 0;
          if (Math.abs(rotateX) < 0.001) rotateX = 0;
          if (Math.abs(scale) < 0.001) scale = 0;
    
          const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(slideTransform);
    
          $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
    
          if (params.slideShadows) {
            // Set shadows
            let $shadowBeforeEl = isHorizontal
              ? $slideEl.find('.swiper-slide-shadow-left')
              : $slideEl.find('.swiper-slide-shadow-top');
            let $shadowAfterEl = isHorizontal
              ? $slideEl.find('.swiper-slide-shadow-right')
              : $slideEl.find('.swiper-slide-shadow-bottom');
            if ($shadowBeforeEl.length === 0) {
              $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');
            }
            if ($shadowAfterEl.length === 0) {
              $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');
            }
            if ($shadowBeforeEl.length)
              $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
            if ($shadowAfterEl.length)
              $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
          }
        }
      };
      const setTransition = (duration) => {
        const { transformEl } = swiper.params.coverflowEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements
          .transition(duration)
          .find(
            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left',
          )
          .transition(duration);
      };
    
      effectInit({
        effect: 'coverflow',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          watchSlidesProgress: true,
        }),
      });
    }
    ",
    "import createShadow from '../../shared/create-shadow.js';
    import effectInit from '../../shared/effect-init.js';
    import effectTarget from '../../shared/effect-target.js';
    import effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';
    
    export default function EffectCreative({ swiper, extendParams, on }) {
      extendParams({
        creativeEffect: {
          transformEl: null,
          limitProgress: 1,
          shadowPerProgress: false,
          progressMultiplier: 1,
          perspective: true,
          prev: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1,
          },
          next: {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            opacity: 1,
            scale: 1,
          },
        },
      });
    
      const getTranslateValue = (value) => {
        if (typeof value === 'string') return value;
        return `${value}px`;
      };
    
      const setTranslate = () => {
        const { slides, $wrapperEl, slidesSizesGrid } = swiper;
        const params = swiper.params.creativeEffect;
        const { progressMultiplier: multiplier } = params;
    
        const isCenteredSlides = swiper.params.centeredSlides;
    
        if (isCenteredSlides) {
          const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
          $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
        }
    
        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideProgress = $slideEl[0].progress;
          const progress = Math.min(
            Math.max($slideEl[0].progress, -params.limitProgress),
            params.limitProgress,
          );
          let originalProgress = progress;
    
          if (!isCenteredSlides) {
            originalProgress = Math.min(
              Math.max($slideEl[0].originalProgress, -params.limitProgress),
              params.limitProgress,
            );
          }
    
          const offset = $slideEl[0].swiperSlideOffset;
          const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
          const r = [0, 0, 0];
          let custom = false;
          if (!swiper.isHorizontal()) {
            t[1] = t[0];
            t[0] = 0;
          }
          let data = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1,
          };
          if (progress < 0) {
            data = params.next;
            custom = true;
          } else if (progress > 0) {
            data = params.prev;
            custom = true;
          }
          // set translate
          t.forEach((value, index) => {
            t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(
              progress * multiplier,
            )}))`;
          });
          // set rotates
          r.forEach((value, index) => {
            r[index] = data.rotate[index] * Math.abs(progress * multiplier);
          });
    
          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
    
          const translateString = t.join(', ');
          const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
          const scaleString =
            originalProgress < 0
              ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`
              : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
          const opacityString =
            originalProgress < 0
              ? 1 + (1 - data.opacity) * originalProgress * multiplier
              : 1 - (1 - data.opacity) * originalProgress * multiplier;
          const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
    
          // Set shadows
          if ((custom && data.shadow) || !custom) {
            let $shadowEl = $slideEl.children('.swiper-slide-shadow');
            if ($shadowEl.length === 0 && data.shadow) {
              $shadowEl = createShadow(params, $slideEl);
            }
            if ($shadowEl.length) {
              const shadowOpacity = params.shadowPerProgress
                ? progress * (1 / params.limitProgress)
                : progress;
              $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
            }
          }
    
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform).css({ opacity: opacityString });
          if (data.origin) {
            $targetEl.css('transform-origin', data.origin);
          }
        }
      };
    
      const setTransition = (duration) => {
        const { transformEl } = swiper.params.creativeEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    
        effectVirtualTransitionEnd({ swiper, duration, transformEl, allSlides: true });
      };
    
      effectInit({
        effect: 'creative',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => swiper.params.creativeEffect.perspective,
        overwriteParams: () => ({
          watchSlidesProgress: true,
          virtualTranslate: !swiper.params.cssMode,
        }),
      });
    }
    ",
    "import createShadow from '../../shared/create-shadow.js';
    import effectInit from '../../shared/effect-init.js';
    import effectTarget from '../../shared/effect-target.js';
    import effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';
    
    export default function EffectCards({ swiper, extendParams, on }) {
      extendParams({
        cardsEffect: {
          slideShadows: true,
          transformEl: null,
          rotate: true,
        },
      });
    
      const setTranslate = () => {
        const { slides, activeIndex } = swiper;
        const params = swiper.params.cardsEffect;
        const { startTranslate, isTouched } = swiper.touchEventsData;
        const currentTranslate = swiper.translate;
        for (let i = 0; i < slides.length; i += 1) {
          const $slideEl = slides.eq(i);
          const slideProgress = $slideEl[0].progress;
          const progress = Math.min(Math.max(slideProgress, -4), 4);
          let offset = $slideEl[0].swiperSlideOffset;
          if (swiper.params.centeredSlides && !swiper.params.cssMode) {
            swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
          }
          if (swiper.params.centeredSlides && swiper.params.cssMode) {
            offset -= slides[0].swiperSlideOffset;
          }
          let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
          let tY = 0;
          const tZ = -100 * Math.abs(progress);
          let scale = 1;
          let rotate = -2 * progress;
    
          let tXAdd = 8 - Math.abs(progress) * 0.75;
    
          const slideIndex =
            swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
    
          const isSwipeToNext =
            (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&
            progress > 0 &&
            progress < 1 &&
            (isTouched || swiper.params.cssMode) &&
            currentTranslate < startTranslate;
          const isSwipeToPrev =
            (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&
            progress < 0 &&
            progress > -1 &&
            (isTouched || swiper.params.cssMode) &&
            currentTranslate > startTranslate;
    
          if (isSwipeToNext || isSwipeToPrev) {
            const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
            rotate += -28 * progress * subProgress;
            scale += -0.5 * subProgress;
            tXAdd += 96 * subProgress;
            tY = `${-25 * subProgress * Math.abs(progress)}%`;
          }
    
          if (progress < 0) {
            // next
            tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
          } else if (progress > 0) {
            // prev
            tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
          } else {
            tX = `${tX}px`;
          }
          if (!swiper.isHorizontal()) {
            const prevY = tY;
            tY = tX;
            tX = prevY;
          }
    
          const scaleString =
            progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
    
          const transform = `
            translate3d(${tX}, ${tY}, ${tZ}px)
            rotateZ(${params.rotate ? rotate : 0}deg)
            scale(${scaleString})
          `;
    
          if (params.slideShadows) {
            // Set shadows
            let $shadowEl = $slideEl.find('.swiper-slide-shadow');
            if ($shadowEl.length === 0) {
              $shadowEl = createShadow(params, $slideEl);
            }
            if ($shadowEl.length)
              $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
          }
    
          $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
          const $targetEl = effectTarget(params, $slideEl);
          $targetEl.transform(transform);
        }
      };
    
      const setTransition = (duration) => {
        const { transformEl } = swiper.params.cardsEffect;
        const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
        $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);
    
        effectVirtualTransitionEnd({ swiper, duration, transformEl });
      };
    
      effectInit({
        effect: 'cards',
        swiper,
        on,
        setTranslate,
        setTransition,
        perspective: () => true,
        overwriteParams: () => ({
          watchSlidesProgress: true,
          virtualTranslate: !swiper.params.cssMode,
        }),
      });
    }
    "
    ]
    }